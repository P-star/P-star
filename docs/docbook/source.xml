<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../docbook-xml-4.5/docbookx.dtd">
<book>
	<title>The P* Web Programming Language</title>
	<chapter>
		<title>Introduction</title>
		<section>
			<title>Logo</title>
			<mediaobject>
			<imageobject>
			<imagedata fileref="images/logo.png"/>
			</imageobject>
			<textobject>
			<phrase>
			</phrase>
			</textobject>
			</mediaobject>
		</section>
		<section>
			<title>What is P*?</title>
			<para>P* (P-star) is a shortname for "Web P* Language". It is unknown what the "P" actually stands for, so a star is used to indicate that any word starting with a "P" may be used. It does not mean that the name can be any number of P's. Oh, by the way, the word has to relate to computers. If you didn't think about any non-computer P-word, you're in the target audience of this article.
			</para>
			<para>P* is a computer programming language specifically designed to make web progamming easy by incorporating frequent operations into the language. P* uses a C-like syntax, so it would be easy to begin using if you have ever used C, C#, C++, Java, Perl, PHP and many others. P* is also highly inspired from some of these languages, and tries to implement the best of them while also using completely new methods for solving different programming tasks.
			</para>
			<para>P* is run as a script by its interpreter, which is written in C++. It is currently under development so if you have any suggestions for new features, shout out now! Also feel free to write new features and send them in.
			</para>
			<para>
			P* is free software and is currently licenced with GPLv3 <ulink>http://www.gnu.org/copyleft/gpl.html</ulink>
			</para>
			<para>
				This docbook is written by Atle Solbakken <email>atle@goliathdns.no</email>
			</para>
		</section>
		<section>
			<title>Mailing lists</title>
			<para>
			<email>p-star-users@googlegroups.com</email> - Mailing list for help and general discussion
			</para>
			<para>
			<email>p-star-dev@googlegroups.com</email> - Mailing list for development
			</para>
		</section>
		<section>
			<title>We want meat!</title>
			<para>This is the official "Hello World!" example of P* program:
			<programlisting language="c">
#!/usr/bin/wpl -f
SCENE main {
	echo "Hello World!\n";
}
</programlisting>
			</para>
			<para>
			To build and run P*, you need to have the libraries and development packages of mysql-client and mimetic. You also need autotools installed. This is how you download and build P* using your favourite shell:
			</para>
			<programlisting language="shell">
git clone https://github.com/atlesn/P-star.git
cd P-star
autoreconf -i
./configure
make install
</programlisting>
			<para>
			You should specify an alternative directory to install P* in so that you can easily remove it later.
			This is done by adding <code>prefix=my_directory</code> when running configure, like <code>./configure --prefix=/usr/test</code>. The files will then be placed in /usr/test/bin and /usr/test/lib.
			</para>
			<para>
			To run P* when you have specified an alternative install path, you should run this first:
			</para>
			<programlisting language="shell">
export LD_LIBRARY_PATH=/usr/test/lib
export PATH=$PATH:/usr/test/bin
</programlisting>
			<para>
			Then the fun part: Create a file named <code>my_program.pstar</code> and paste in the text from the Hello-World example above.
			Then do this to run the program:
			</para>
			<programlisting language="shell">
wpl -f my_program.pstar
</programlisting>
		</section>
		<section>
			<title>Why Another Language?</title>
			<para>You might think that if someone decides to begin on the huge task of designing a new programming language, that someone has probably gone crazy.
			And you're spot on. Years of fierce fighting with different programming languages can drive the most well-composed person mad (this 'someone' we refer to here has never been well-composed, but if he was before he started programming, he would certeinly have lost that property by now).
			</para>
			<para>P* tries to simplify tasks like HTML templates and database handling, where most languages use procedural and error-prone methods. P* introduces completely new methods of making life easier when dealing with this.
			</para>
		</section>
	</chapter>
	<chapter>
		<title>Get P*!</title>
		<para>
		The source of P* is currently available
<ulink url="https://github.com/atlesn/P-star">from Github</ulink>.
		</para>
		<para>
		<code>$ git clone https://github.com/atlesn/P-star.git</code>
		</para>
		<para>
		You can also <ulink url="http://www.p-star.org/dox/html/">browse the source code</ulink>
		</para>
	</chapter>		
	<chapter>
		<title>The P* language</title>
		<para>All programming languages have advantages and disadvantages. These two creatures are happily married, and they can't be separated. If you try to kill a disadvantage, it's beloved advantage will commit suicide, and you're back where you started. If you overlap a disadvantage with another advantage, a new disadvantage comes along with it.
		</para>
		<para>
		Does this mean that we will never have a perfect programming lanuage?
		It probably does.
		However, P* has made an attempt to get around this by selecting which bad things to have first and seeing what advantages we get with those afterwards.
		</para>
		<para>A P* program is run by an interpreter engine, and this is bad for speed.
		We compensate for that by making the language simple, which actually has the side effect of making it suitable for web programming.
		What web programming is about is, yes you guessed correct, "web", and the tools to create the web should be designed with that in mind.
		</para>
		<section>
			<title>Program layout and scenes</title>
			<para>All code in P* programs sits inside <code>SCENE</code> blocks.
			A program is required to provide a <code>SCENE</code> called <code>main</code>, which is the first one to be run by the interpreter.
			P* will crash with an error message if the <code>SCENE main</code> is missing.
			There may be no duplicate scene names, and they cannot nest.
			</para>
			<para>
			Scenes, apart from the <code>main</code> scene are called using the <code>#SCENE</code>-pragma.
			A scene may access all variables from it's caller.
			</para>
			<para>A simple P* program with two scenes might look like this:
			</para>
			<programlisting language="c">
#!/usr/bin/wpl -f
SCENE my_scene {
	/* Print out the value of the 'text'-variable */
	echo "This is my_scene: '$text'\n";
}

SCENE main {
	/* Create a string variable */
	string text = "Hello world!";

	/* Call the other scene */
	#SCENE my_scene;
}
</programlisting>
			<para>This program will output</para>
			<programlisting>
This is my_scene: 'Hello world!'
</programlisting>
			<bridgehead>Scene inheritance</bridgehead>
			<para>A scene can extend another scene. This is useful for instance if we want to put configuration stuff inside a scene and include it in other scenes.
			</para>
			<para>In a scene inheritance setup, we can use the keywords <code>private</code> and <code>protected</code> to restrict access to variables and functions.
			If we don't specify any keyword, private is assumed.
			</para>
			<para>A variable or function which is private can only be accessed from within the same scene, but protected ones can be accessed from derived scenes.
			</para>
			<para>Base scenes are specified by putting a colon <code>:</code> after the scene name followed by a comma separated list of the base scenes, like <code>SCENE main : b, c</code>. Base scenes are run prior to the derived scene in the order in which they are defined.
			</para>
			<para>The example below has a total of four scenes which inherits from each other.
			The main scene inherits from scene <code>b</code> and <code>c</code>, which makes them base scenes of main.
			Scene <code>b</code> inherits further from scene <code>a</code>, and the order of execution of all the scenes will be <code>a -> b -> c -> main</code>
			</para>
			<para>If we call a function of a base scene from a derived scene, the function can access private variables of the scene in which it is defined.
			</para>
			<programlisting language="c">
SCENE a {
	echo "This is A\n";
}

SCENE b : a {
	echo "This is B\n";

	/* This variable is private, and can only be accessed from within b */
	int var_b = 1;

	/* This function is protected, and can be accessed from derived scenes */
	protected int b_function(int argument) {
		echo "This is B's function:\n";

		/* The function can access the private variable var_b */
		echo "\tvar_b is " . var_b . "\n";
	}
}

SCENE c {
	/* This variable is protected, and can be accessed from derived scenes */
	protected int var_c = 2;

	echo "This is C: var_c is " . var_c . "\n";
}

SCENE main : b, c {
	/* Here, the protected variable var_c is accessed */
	echo "This is Main: var_c is " . var_c . "\n";

	/* Call the protected function b_function */
	b_function();
}

</programlisting>
			<para>When this program is run, it will output:</para>
			<programlisting>
This is A
This is B
This is C: var_c is 2
This is Main: var_c is 2
This is B's function:
	var_b is 1
</programlisting>
		</section>
		<section>
			<title>Types</title>
			<para>One important element of making a program efficient, is to use correct types for your variables.
			When you've programmed for a while, type selection becomes natural, and you don't think much about it.
			</para>
			<para>Some languages try to help the user by using automatic types.
			This is supposed to make it easier to write.
			P* does allow implicit converting between primitive types, but no variables can be typeless.
			</para>
			<para>It is not much work to write <code>int</code> or <code>string</code> in front of a variable.
			A good thing about this is that it helps make programs more readable, and it's an easy way for developers to make programs efficient.
			</para>
			<para>Variables in P* are stored in memory as their C/C++ equalient type. Size of the type depends on the platform the interpreter is compiled on.
			</para>
			<table>
				<title>List of P* primitive types</title>
				<tgroup cols="3">
				<colspec colname="c1"/>
				<colspec colname="c2"/>
				<colspec colname="c3"/>
				<thead>
					<row>
						<entry>Name</entry>
						<entry>Description</entry>
						<entry>Example</entry>
						<entry>C-equalient</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>int</entry>
						<entry>Signed integer</entry>
						<entry>int a = "-10";</entry>
						<entry>long int</entry>
					</row>
					<row>
						<entry>uint</entry>
						<entry>Unsigned integer</entry>
						<entry>uint a = 10;</entry>
						<entry>long unsigned int</entry>
					</row>
					<row>
						<entry>llint</entry>
						<entry>Long long signed integer</entry>
						<entry>llint a = "-10";</entry>
						<entry>long long int</entry>
					</row>
					<row>
						<entry>lluint</entry>
						<entry>Long long unsigned integer</entry>
						<entry>lluint a = 10;</entry>
						<entry>long long unsigned int</entry>
					</row>
					<row>
						<entry>float</entry>
						<entry>Single precision floating point</entry>
						<entry>float a = "2.00003";</entry>
						<entry>float</entry>
					</row>
					<row>
						<entry>double</entry>
						<entry>Double precision floating point</entry>
						<entry>double a = "2.00003";</entry>
						<entry>double</entry>
					</row>
					<row>
						<entry>bool</entry>
						<entry>Boolean true or false (1 or 0)</entry>
						<entry>bool a = 1;</entry>
						<entry>bool</entry>
					</row>
					<row>
						<entry>string</entry>
						<entry>String value</entry>
						<entry>string text = "P* Web Programming Language";</entry>
						<entry>Uses <code>&lt;string&gt;</code> from C++</entry>
					</row>
					<row>
						<entry>auto</entry>
						<entry>Automatic type</entry>
						<entry>auto var = "P* Web Programming Language";</entry>
						<entry>Automatic type selection based on the first assignment.</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
			<bridgehead>Example of usage of different data types</bridgehead>
			<programlisting language="c">
SCENE main {
	int base = 2;
	int exp = 1;
	int exp_max = 20;
	lluint result = 1;

	while (exp &lt;= exp_max) {
		result *= base;
		echo "$base exp $exp is $result\n";
		exp++;
	}

}
</programlisting>
			<para>This program will output</para>
			<programlisting>
2 exp 1 is 2
2 exp 2 is 4
2 exp 3 is 8
2 exp 4 is 16
2 exp 5 is 32
2 exp 6 is 64
2 exp 7 is 128
2 exp 8 is 256
2 exp 9 is 512
2 exp 10 is 1024
2 exp 11 is 2048
2 exp 12 is 4096
2 exp 13 is 8192
2 exp 14 is 16384
2 exp 15 is 32768
2 exp 16 is 65536
2 exp 17 is 131072
2 exp 18 is 262144
2 exp 19 is 524288
2 exp 20 is 1048576
</programlisting>
			</section>
			<section>
			<title>Strings</title>
			<para>P* supports defining strings inside the double quote <code>"</code> or single quote <code>'</code>.
			</para>
			<para>P* allows you to interpolate variables inside a text string delimited by double quotes. A variable to be interpolated is prefixed with the dollar sign, <code>$</code>.
			The string output operators <code>echo</code> and <code>errcho</code> internally use the C++ <code>iostream</code> output methods <code>cout</code> and <code>cerr</code>.
			</para>
			<para>In P*, you can concatenate string using the dot operator, <code>.</code>.
			</para>
			<para>
			A double quote delimited string supports the following replacement escape sequences:
			</para>
			<table>
				<title>List of double quote escape sequences</title>
				<tgroup cols="2">
				<colspec colname="c1"/>
				<colspec colname="c2"/>
				<thead>
					<row>
						<entry>Sequence</entry>
						<entry>Is replaced with</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>\0</entry>
						<entry>A NULL character</entry>
					</row>
					<row>
						<entry>\a</entry>
						<entry>ASCII code 7, BEL (bell)</entry>
					</row>
					<row>
						<entry>\b</entry>
						<entry>ASCII code 8, BS (backspace)</entry>
					</row>
					<row>
						<entry>\t</entry>
						<entry>ASCII code 9, TAB (horizontal tab)</entry>
					</row>
					<row>
						<entry>\n</entry>
						<entry>ASCII code 10, LF (newline)</entry>
					</row>
					<row>
						<entry>\v</entry>
						<entry>ASCII code 11, VT (vertical tab)</entry>
					</row>
					<row>
						<entry>\r</entry>
						<entry>ASCII code 13, CR (carriage return)</entry>
					</row>
					<row>
						<entry>\"</entry>
						<entry>ASCII code 34, " (double quotes)</entry>
					</row>
					<row>
						<entry>\/</entry>
						<entry>ASCII code 47, / (forward slash)</entry>
					</row>
					<row>
						<entry>\\</entry>
						<entry>ASCII code 92, \ (backslash)</entry>
					</row>
					<row>
						<entry>\$</entry>
						<entry>ASCII code 36, $ (dollar sign)</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
			<para>
			P* will issue an error if you use a double quote escape sequence which is not defined. Single quotes only support the escape sequence <code>\'</code>, and all other sequences with backslash are interpreted literally without any errors.
			</para>
			<bridgehead>Example of string usage</bridgehead>
			<programlisting language="c">
SCENE main {
	int num = 2;

	echo "The number is $num\n";
	echo 'The number is $num\n';
}
</programlisting>
			<para>This program will output</para>
			<programlisting>
The number is 2
The number is $num\n
</programlisting>
		</section>
		<section>
			<title>Loops and blocks</title>
			<para>An important part of a programming language is to be able to control the program flow. For simplicity, P* has been inspired by other languages and supports the common loop- and conditional blocks.</para>
			<bridgehead>If block</bridgehead>
			<para>The <code>if</code>, <code>else if</code> and <code>else</code> blocks is probably the most widely used flow control blocks of all time.
			The code in an <code>if</code> block is only run if the condition you specify is true.
			If it is false, the condtition of the next <code>else if</code> is checked, and that block's code is run if the condition was true.</para>
			<para>You can specify as many <code>else if</code> blocks as you want.
			When the first true condition is found, that block is run, and none of the remaining conditions below are checked. Never is more than one block in an <code>if</code>-<code>else if</code>-<code>else</code> construct run.</para>
			<para>In the end, you can specify an <code>else</code> block.
			This block doesn't have any condition, and is run if all the other conditions was false.</para>
			<para>Try to run this program and replace <code>Banana</code> on the third line with different values:</para>
			<programlisting language="c">
SCENE main {
	/* Set the string my_fruit to contain Banana */
	string my_fruit = "Banana";

	/* This string will contain the color of the fruit, but it's empty for now */
	string color;

	if (my_fruit == "Banana") {
		/* The fruit was a Banana, set color to "yellow" */
		color = "yellow";
	}
	else if (my_fruit == "Orange") {
		/* The fruit was an Orange, set color to "orange" */
		color = "orange";
	}
	else {
		/* The fruit is neither a Banana or an Orange, we don't know it's color */
		color = "unknown";
	}

	echo "The color of the fruit $my_fruit is $color\n";
}
</programlisting>
			<bridgehead>While loop</bridgehead>
			<para>A <code>while</code> loop is run many times while the specified condition is true.
			You can use anything as a condition, but in this example, we use only the number <code>1</code> as condition, which makes it run indefinitly.
			Inside the loop below, we have put a <code>break</code> statement which makes the program immediately jump out of the loop and continue below.</para>
			<para>This kind of construct is useful to make the code more readable if we hav many different conditions to check for.
			In this loop we increment the variable <code>counter</code> by <code>1</code> at the end of every run.
			If the counter is less than 5, we print one message, and if it's more than five but below ten we print another message.
			When the counter reaches 10, we break out of the loop. Try to run it!
			</para>
			<programlisting language="c">
SCENE main {
	/* Set our counter to zero */
	int counter = 0;

	/* This loop runs indefinitly untill we end it with a break */
	while (1) {
		if (counter &lt; 5) {
			/* Check if counter is less than five */
			echo "The counter is currently less than five\n";
		}
		else if (counter &lt; 10) {
			/* Check if counter is less than ten */
			echo "The counter is currently less than ten\n";
		}
		else {
			/* Counter is not less than ten if we end up here */
			echo "The counter is now 10, end the loop now\n";
			break;
		}

		/* Increment the counter */
		counter++;
	}
}
</programlisting>

			<bridgehead>For loop</bridgehead>
			<para>The <code>for</code> loop is mostly used to keep a counter which increments each run and then end when it reaches a certain value.
			In addition to the condition the <code>while</code> loop has, it provides two extra fields: One which is run before the loop starts the first time and one which is run at the end of each iteration.</para>
			<para>The example below gives the same output as the program with the <code>while</code> loop.
			Note that we have put the <code>counter = 0</code> and <code>counter++</code> expressions in a different location, but they are still run at the same time as in the <code>while</code> loop.</para>
			<programlisting language="c">
SCENE main {
	/* Create the counter variable */
	int counter;

	/* Set counter to zero and loop while the counter is less than five */
	for (counter = 0; counter &lt; 5; counter++) {
		echo "The counter is currently less than five\n";
	}

	/* Do nothing the first run (counter is still the same as when we
	ended the first loop), and run while the counter is less than 10. */
	for (0; counter &lt; 10; counter++) {
		echo "The counter is currently less than ten\n";
	}

	echo "The counter is now 10, end the loop now\n";
}
</programlisting>
			<para>A <code>while</code> can always be replaced by a <code>for</code> loop and vice versa, choose the one which makes the code easier to read.</para>
			<bridgehead>Foreach loop</bridgehead>
			<para>The foreach loop is meant to further simplify how we control a loop.
The condition of a foreach loop may contain a list or range operation.
			A variable is specified used to store the value we get from the condition, and the loop runs untill all values in the list have been used once.
			</para>
			<para>Go ahead and check if the program below produces the same output as the two previous programs!</para>
			<programlisting language="c">
SCENE main {
	/* Create the counter variable */
	int counter;

	/* Loop values 0 through 4 and put the value into the counter for each run */
	foreach (counter; 0..4) {
		echo "The counter is currently less than five\n";
	}

	/* The counter is now four, but since we've already done that number,
	we use the exclusive range operator ... (three dots) which keeps out
	the lowest and highest number of the range. This loop will run from 5
	to 9. */
	foreach (counter; counter...10) {
		echo "The counter is currently less than ten\n";
	}

	/* The counter never actually becomes 10, but we just keep this message anyway */
	echo "The counter is now 10, end the loop now\n";
}
</programlisting>
		</section>
		<section>
			<title>Regular expressions</title>
			<para>P* has adopted the neat and simple regular expression syntax from the Perl language. Regular expression are delimeted with slashes. Here is an example of a program which uses regular expressions:</para>
			<programlisting language="c">
SCENE main {
	/* Create a strange string */
	string test = "aaa   bbbb";

	/* Check if a regular expression matches */
	if (test =~ /a\s*b/) {
		echo "Does match\n";
	}

	/* Check if a regular expression does not match */
	if (test !~ /ffff/) {
		echo "Does not match\n";
	}
}
</programlisting>
			<para>You can interpolate variables into the regular expression by using the <code>$</code>-prefix.
			The content of the variable is considiered a part of the regular expression syntax, so to avoid funny behaviour, you might want to escape special characters like <code>. \ + * ? [ ^ ] $ ( ) { } = ! &lt; &gt; | : -</code>.
			</para>
			<para>You can escape a variable by using the <code>\Q \E</code>-method, like this:</para>
			<programlisting language="c">
SCENE main {
	ENV env;
	string search = "/cgi-bin/test.pstar";

	/* Check if script name ends with $search, while making
	   sure that the forward slashes are escaped.
	 */
	if (env->SCRIPT_NAME =~ /\Q$search\E$/) {
		echo "This script is placed inside the cgi-bin directory";
	}
}
</programlisting>
			<para>Notice that the variable interpolation prefix <code>$</code> is treated as end-of-string if not directly followed by a word character.</para>
			<bridgehead>Flags</bridgehead>
			<para>One or more flags may be used by specifing them directly after the last <code>/</code> of the regular expression. These change the way the regular expression works.</para>
			<table>
				<title>Regular Expression flags</title>
				<tgroup cols="2">
				<colspec colname="c1"/>
				<colspec colname="c2"/>
				<thead>
					<row>
						<entry>Flag</entry>
						<entry>Name</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>/q</entry>
						<entry>Automatic meta-quote</entry>
						<entry>Automatically escape all inline variables with <code>\Q \E</code></entry>
					</row>
					<row>
						<entry>/g</entry>
						<entry>Global</entry>
						<entry>Run the regular expression several times untill the end of the string is reached.</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
			<bridgehead>Store matches</bridgehead>
			<para>When a regular expression has matched, it pushes the full match and sub-matches onto the discard queue. The discard queue is a hidden array in all expressions, and we can push it onto an array later by using the <code>=></code> operator.</para>
			<programlisting language="c">
SCENE main {
	string subject = "aabbc";
	array&lt;string&gt; matches;

	/* Push the matches in the regular expression into the matches-array */
	test =~ /..|./g => matches;

	int i;
	for (i = 0; i &lt; @matches-1; i++) {
		echo "Match $i: '" . matches[i] . "'\n";
	}

	/* This will print out:
Match 0: 'aa'
Match 1: 'bb'
Match 2: 'c'
	*/
}
</programlisting>
			<para>Note that the <code>=></code> operator also pushes the last value, which is left of it, onto the array.
			In this case, this value is 'true', since the regular expression matched.
			We should therefore ignore the last element of the array, hence the <code>-1</code> (minus 1) in the for-loop.</para>
			<bridgehead>Text replacement</bridgehead>
			<para>Like in the Perl lanugage, you can use regular expressions to replace text.
			To use matches from the regular expression in the replacement part, we can use the special variables <code>$0 $1 $2 $3</code>.
			The full match, everything between <code>/ /</code> is placed into <code>$0</code>. The first sub-expression (inside <code>( )</code> is placed into <code>$1</code>, the second in <code>$2</code> and so on.
			These variables are only available inside regular expressions.</para>
			<programlisting language="c">
SCENE main {
        string subject = "23 24 25 26 27";

	echo "Before: $subject\n";

	/* Replace all '2's with the character following them */
	subject =~ s/2(.)/$1$1/g;

	echo " After: $subject\n";
}
</programlisting>
			<para>This program will output</para>
			<programlisting>
Before: 23 24 25 26 27
 After: 33 44 55 66 77
</programlisting>
			<bridgehead>More regex!</bridgehead>
			<para>Take a look at to the <ulink url="http://perldoc.perl.org/perlre.html">Perl documentation for regular expressions</ulink> for more information.</para>
		</section>
		<section>
			<title>Functions</title>
			<para>The P* function syntax is equal to that of the C-language. A function needs to have a return value of a specific type.
			A function may have zero or more arguments. Functions do not inherit variables from the caller. Functions need to have unique names, function overloading is currently not supported. Functions need to be defined inside scenes.
			</para>
			<para>
			Variables passed into a function are usually copied (pass-by-value). Some objects however, like MySQL-objects, are implicitly passed as reference instead (pass-by-reference). The documentation of these special types tells you which are passed by reference.
			</para>
			<para>
			Primitive data types like <code>int</code> and <code>string</code> are implicity converted between each other to mach the function arguments (weak type checking).
			</para>
			<para>
			In the example below, we have a function with return type of <code>int</code> called <code>sum</code>.
			This function takes two integer arguments and returns their sum.
			We pass in a string as the second argument to show that it is implicitly converted into an integer when passed into the function.
			</para>
			<programlisting language="c">
SCENE main {
	/* Define a function which takes two integer arguments */
	int sum(int a, int b) {
		echo "Adding number $a and $b\n";
		return a + b;
	}

	/* Declare an integer variable 'result' */
	int result;

	/* Call the sum-function and put the result into the 'result'-variable */
	/* The string "3" is implicitly converted into an integer */
	result = sum(1, "3");

	echo "The result is $result\n";
}
</programlisting>
			<para>This program will output</para>
			<programlisting>
Adding number 1 and 3
The result is 4
</programlisting>
		</section>
		<section>
			<title>Expressions and operators</title>
			<para>P* have mostly adapted operators and their precedence from the C-language.
			The basics of the expression syntax is also the same as in C.
			Expressions are run right to left.
			Most operators are mapped directly to their C-equalient, and behave the same way.
			</para>
			<para>The associativity for an operator decides the return value of the expression.
			In the example below, we see that the return value of the expression is different depending on which variable we have on the left side of the <code>+</code> operator.</para>
			<programlisting language="c">
SCENE main {
	int a = 10;
	float b = "1.5";

	/* The expression a + b will return an integer */
	echo "Integer result: " . (a + b) . "\n";

	/* The expression b + a will return a float */
	echo "Float result: " . (b + a) . "\n";
}
</programlisting>
			<para>This program will output</para>
			<programlisting>
Integer result: 11
Float result: 11.500000
</programlisting>
			<table>
				<title>Operators in P*</title>
				<tgroup cols="2">
				<colspec colname="c1" align="center" />
				<colspec colname="c2" align="center" />
				<colspec colname="c3"/>
				<colspec colname="c4" align="center" />
				<colspec colname="c5"/>
				<thead>
					<row>
						<entry>Precedence</entry>
						<entry>Operator</entry>
						<entry>Description</entry>
						<entry>Associativity</entry>
						<entry>Example</entry>
					</row>
				</thead>
				<tbody>
				abbc
					<row>
						<entry morerows="5">1</entry>
						<entry><code>()</code></entry>
						<entry>Function call</entry>
						<entry>Left or none</entry>
						<entry><code>call(2,3)</code></entry>
					</row>
					<row>
						<entry><code>[]</code></entry>
						<entry>Array subscription (hashes and arrays)</entry>
						<entry morerows="1">Left</entry>
						<entry><code>my_array[2]</code></entry>
					</row>
					<row>
						<entry><code>-&gt;</code></entry>
						<entry>Element selection (structs and classes)</entry>
						<entry><code>my_struct-&gt;variable</code></entry>
					</row>
					<row>
						<entry><code>*</code></entry>
						<entry>Indirection - Return the value of a pointer</entry>
						<entry morerows="2">Right</entry>
						<entry><code>*my_pointer</code></entry>
					</row>
					<row>
						<entry><code>*</code></entry>
						<entry>First element selector - Returns first element of an array, same as [0]</entry>
						<entry><code>*my_array</code></entry>
					</row>
					<row>
						<entry><code>&amp;</code></entry>
						<entry>Pointer To - Returns a pointer to a value</entry>
						<entry><code>&amp;my_value</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry morerows="5">2</entry>
						<entry><code>++</code></entry>
						<entry>Postfix increment</entry>
						<entry morerows="1">Left</entry>
						<entry><code>i++</code></entry>
					</row>
					<row>
						<entry><code>--</code></entry>
						<entry>Postfix decrement</entry>
						<entry><code>i--</code></entry>
					</row>
					<row>
						<entry><code>@</code></entry>
						<entry>Element counter (arrays and hashes)</entry>
						<entry morerows="3">Right</entry>
						<entry><code>@my_array</code></entry>
					</row>
					<row>
						<entry><code>isempty</code></entry>
						<entry>Empty check logic (strings)</entry>
						<entry><code>isempty my_string</code></entry>
					</row>
					<row>
						<entry><code>defined</code></entry>
						<entry>Check if array, hash or ENV element is defined</entry>
						<entry><code>defined my_array[2]</code></entry>
					</row>
					<row>
						<entry><code>keys</code></entry>
						<entry>Return an array of all keys in a hash</entry>
						<entry><code>my_array&lt;string&gt; keys_of_hash = keys my_hash</code></entry>
					</row>
					<row>
						<entry morerows="3">3</entry>
						<entry><code>++</code></entry>
						<entry>Prefix increment</entry>
						<entry morerows="3">Right</entry>
						<entry><code>++i</code></entry>
					</row>
					<row>
						<entry><code>--</code></entry>
						<entry>Prefix decrement</entry>
						<entry><code>--i</code></entry>
					</row>
					<row>
						<entry><code>~</code></entry>
						<entry>Bitwise not</entry>
						<entry><code>~invert_this</code></entry>
					</row>
					<row>
						<entry><code>!</code></entry>
						<entry>Logical not</entry>
						<entry><code>!var</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry morerows="1">4</entry>
						<entry><code>=~</code></entry>
						<entry>Pattern match</entry>
						<entry morerows="1">Left</entry>
						<entry><code>a =~ /regular expression/</code></entry>
					</row>
					<row>
						<entry><code>!~</code></entry>
						<entry>Pattern negative match</entry>
						<entry><code>a !~ /regular expression/</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry morerows="2">5</entry>
						<entry><code>*</code></entry>
						<entry>Multiplication</entry>
						<entry morerows="6">Left</entry>
						<entry><code>a*b</code></entry>
					</row>
					<row>
						<entry><code>/</code></entry>
						<entry>Division</entry>
						<entry><code>dividend / divisor</code></entry>
					</row>
					<row>
						<entry><code>%</code></entry>
						<entry>Modulus</entry>
						<entry><code>dividend % divisor</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry morerows="2">6</entry>
						<entry><code>+</code></entry>
						<entry>Sum</entry>
						<entry><code>number_a + number_b</code></entry>
					</row>
					<row>
						<entry><code>-</code></entry>
						<entry>Subtraction</entry>
						<entry><code>number_a - number_b</code></entry>
					</row>
					<row>
						<entry><code>.</code></entry>
						<entry>String concatenation</entry>
						<entry><code>string_a . string_b</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry morerows="1">7</entry>
						<entry><code>&lt;&lt;</code></entry>
						<entry>Left bitshift</entry>
						<entry morerows="1">Left</entry>
						<entry><code>a &lt;&lt; 1</code></entry>
					</row>
					<row>
						<entry><code>&gt;&gt;</code></entry>
						<entry>Right bitshift</entry>
						<entry><code>a &gt;&gt; 1</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry>8</entry>
						<entry><code>&amp;</code></entry>
						<entry>Bitwise AND</entry>
						<entry morerows="2">Left</entry>
						<entry><code>a &amp; b</code></entry>
					</row>
					<row>
						<entry>9</entry>
						<entry><code>^</code></entry>
						<entry>Bitwise XOR</entry>
						<entry><code>a ^ b</code></entry>
					</row>
					<row>
						<entry>10</entry>
						<entry><code>|</code></entry>
						<entry>Bitwise OR</entry>
						<entry><code>a | b</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry morerows="3">11</entry>
						<entry><code>&lt;=</code></entry>
						<entry>Logical less than or equal</entry>
						<entry morerows="7">Left</entry>
						<entry><code>a &lt;= b</code></entry>
					</row>
					<row>
						<entry><code>&gt;=</code></entry>
						<entry>Logical more than or equal</entry>
						<entry>a &gt;= b</entry>
					</row>
					<row>
						<entry><code>&lt;</code></entry>
						<entry>Logical less than</entry>
						<entry><code>a &lt; b</code></entry>
					</row>
					<row>
						<entry><code>&gt;</code></entry>
						<entry>Logical more than</entry>
						<entry><code>a &gt; b</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry morerows="1">12</entry>
						<entry><code>==</code></entry>
						<entry>Logical equal</entry>
						<entry><code>a == b</code></entry>
					</row>
					<row>
						<entry><code>!=</code></entry>
						<entry>Logical not equal</entry>
						<entry><code>a != b</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry>13</entry>
						<entry><code>&amp;&amp;</code></entry>
						<entry>Logical AND</entry>
						<entry morerows="1">Left</entry>
						<entry><code>a &amp;&amp; b</code></entry>
					</row>
					<row>
						<entry>14</entry>
						<entry><code>||</code></entry>
						<entry>Logical OR</entry>
						<entry><code>a || b</code></entry>
					</row>
					<row>
						<entry morerows="1">15</entry>
						<entry><code>=></code></entry>
						<entry>Push discard chain to array</entry>
						<entry morerows="1">Right</entry>
						<entry><code>10, 20, 30 => my_array</code></entry>
					</row>
					<row>
						<entry><code>==></code></entry>
						<entry>Same as =>, but clears array first</entry>
						<entry><code>10, 20, 30 ==> my_array</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry morerows="11">16</entry>
						<entry><code>=</code></entry>
						<entry>Assign</entry>
						<entry morerows="11">Right</entry>
						<entry><code>a = b</code></entry>
					</row>
					<row>
						<entry><code>+=</code></entry>
						<entry>Assign by sum</entry>
						<entry><code>a += b</code></entry>
					</row>
					<row>
						<entry><code>-=</code></entry>
						<entry>Assign by difference</entry>
						<entry><code>a -= b</code></entry>
					</row>
					<row>
						<entry><code>*=</code></entry>
						<entry>Assign by product</entry>
						<entry><code>a *= b</code></entry>
					</row>
					<row>
						<entry><code>/=</code></entry>
						<entry>Assign by quotient</entry>
						<entry><code>a /= b</code></entry>
					</row>
					<row>
						<entry><code>%=</code></entry>
						<entry>Assign by remainder</entry>
						<entry><code>a %= b</code></entry>
					</row>
					<row>
						<entry><code>&amp;=</code></entry>
						<entry>Assign by bitwise AND</entry>
						<entry><code>a &amp;= b</code></entry>
					</row>
					<row>
						<entry><code>^=</code></entry>
						<entry>Assign by bitwise XOR</entry>
						<entry><code>a ^= b</code></entry>
					</row>
					<row>
						<entry><code>|=</code></entry>
						<entry>Assign by bitwise OR</entry>
						<entry><code>a |= b</code></entry>
					</row>
					<row>
						<entry><code>&lt;&lt;=</code></entry>
						<entry>Assign by bitwise left shift</entry>
						<entry><code>a &lt;&lt;= b</code></entry>
					</row>
					<row>
						<entry><code>&gt;&gt;=</code></entry>
						<entry>Assign by bitwise right shift</entry>
						<entry><code>a &gt;&gt;= b</code></entry>
					</row>
					<row>
						<entry><code>.=</code></entry>
						<entry>Append to string</entry>
						<entry><code>a .= b</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry morerows="1">17</entry>
						<entry><code>..</code></entry>
						<entry>Range operator inclusive</entry>
						<entry morerows="1">Left</entry>
						<entry><code>foreach (i; 0..10) { /* Loops 0 through 10 */ }</code></entry>
					</row>
					<row>
						<entry><code>...</code></entry>
						<entry>Range operator exclusive</entry>
						<entry><code>foreach (i; 0..10) { /* Loops 1 through 9 */ }</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry>18</entry>
						<entry><code>,</code></entry>
						<entry>Discard operator (comma)</entry>
						<entry>Left</entry>
						<entry><code>a, b</code></entry>
					</row>
					<row>
						<entry morerows="1">19</entry>
						<entry><code>echo</code></entry>
						<entry>Write expression to standard output</entry>
						<entry morerows="1">Right</entry>
						<entry><code>echo "Hello world!"</code></entry>
					</row>
					<row>
						<entry><code>errcho</code></entry>
						<entry>Write expression to standard error</entry>
						<entry><code>errcho "This is an error message"</code></entry>
					</row>
					<row>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
						<entry></entry>
					</row>
					<row>
						<entry morerows="1">20</entry>
						<entry><code>break</code></entry>
						<entry>Break out from nearest loop</entry>
						<entry>None</entry>
						<entry><code>break</code></entry>
					</row>
					<row>
						<entry><code>return</code></entry>
						<entry>Return from nearest function</entry>
						<entry>Right or none</entry>
						<entry><code>return 1</code></entry>
					</row>
				</tbody>
				</tgroup>
			</table>
		</section>
		<section>
			<title>Hashes and arrays</title>
			<para>P* supports dynamic sized hashes and arrays. These are template types and can only hold values of the type you specify.
			They can hold any type, including arrays and hashes. This is useful for creating more dimensions.
			An element is created the first time you access it, and the value will be initialized to the type's default value (numbers are 0, strings are empty etc.).</para>
			<bridgehead>array&lt;default type&gt;</bridgehead>
			<para>The array is a list of elements stored in sequential order and access by an index number. 
			Here is an example of an array:
			</para>
			<programlisting language="c">
/* Instantiate an array of type int, no elements are created */
array&lt;int&gt; my_first_array;

/* Set the first three elements of the array to 10, 20 and 30 */
my_first_array[0] = 10;
my_first_array[1] = 20;
my_first_array[2] = 30;

/* Iterate the array and print its values */
int i = 0;
while (i &lt; @my_first_array) {
	echo "The value of element $i is " . my_first_array[i] . "\n";
	i++;
}

/* Output of this program:
The value of element 0 is 10
The value of element 1 is 20
The value of element 2 is 30
*/
</programlisting>
			<para>
			Arrays support the special operators "first element selection" <code>*</code> and "element counter" <code>@</code>. These are used like this:
			</para>
			<programlisting language="c">
/* Instantiate an array of type string, no elements are created */
array&lt;string&gt; my_first_array;

/* Set the value of two elements */
my_first_array[0] = "First element";
my_first_array[1] = "Second element";

/* Count the number of values and print to standard output */
echo "The array has " . @my_first_array . " elements\n";

/* Get the first element and print to standard output */
echo "The value of the first array element is '" . *my_first_array . "'\n";
</programlisting>
			<para>This program will output</para>
			<programlisting>
The array has 2 elements
The value of the first array element is 'First element'
</programlisting>
			<para>
			The array only creates elements you access. If you skip indexes, like if you only use element 0 and 5, the size of the array will be 6, but memory is not allocated for elements 1-4.
			</para>
			<para>
			You may use arrays of multiple dimensions by specifing another array inside the template specifier like this: <code>array&lt;array&lt;int&gt;&gt;</code>.
			To select elements afterwards, use two array subscription operators after eachother like this <code>my_array[0][0]</code> (selects the first element of the first array).
			Under follows an example of this usage.
			<programlisting language="c">
SCENE main {
	array&lt;array&lt;int&gt;&gt; my_array;

	my_array[0][0] = 10;
	my_array[0][1] = 20;

	my_array[1][0] = 30;
	my_array[1][1] = 40;

	int i;
	int j;
	for (i = 0; i &lt; @my_array; i++) {
		for (j = 0; j &lt; @my_array[i+0]; j++) {
			echo "Value: " . my_array[i+0][j+0] . "\n";
		}
	}

	return 0;
}

</programlisting>
			</para>
			<para>You can push a list to the end of an array using a combination of the discard operator <code>,</code>(comma) and the discard save operator <code>=></code>. The discard save operator returns the number of elements added to the array. Here is an example program:</para>
			<programlisting language="c">
SCENE main {
	/* Instantiate and array */
	array&lt;int&gt; my_array;

	/* Push the four numbers into the array */
	int count = (10, 20, "30", 40 => my_array);

	/* Print result */
	echo "Pushed $count values to the array\n";

	int i = "-1";
	while (++i &lt; @my_array) {
		echo "my_array[$i] is " . my_array[i] . "\n";
	}
}
</programlisting>
			<para>This program will output</para>
			<programlisting>
   Pushed 4 values to the array
   my_array[0] is 10
   my_array[1] is 20
   my_array[2] is 30
   my_array[3] is 40
</programlisting>
			<bridgehead>hash&lt;default type&gt;</bridgehead>
			<para>
			A hash is an array except that the values are accessed using string identifiers instead of indexes and that elements are unordered.
			You can use the counter operator <code>@</code> for hashes the same way as for arrays.
			An element of a hash is created the first time you access it.
			</para>
			<para>
			Here is an example program using hashes:
			</para>
			<programlisting language="c">
hash&lt;string&gt; my_pets;

/* Set the two values of the hash */
my_pets["dog"] = "Max";
my_pets["cat"] = "Tiger";

/* Create an array of the keys */
array&lt;string&gt; pet_keys = keys my_pets;

/* Count the elements of the hash and print to standard output */
echo "I have " . @my_pets . " pets.\n";

/* Iterate the array of the keys and print the values of the hash */
int i = 0;
while (i &gt; @pet_keys) {
	echo "The name of my " . pet_keys[i] . " is '" . my_pets[pet_keys[i]] . "'.\n";
	i++;
}
</programlisting>
			<para>This program will output</para>
			<programlisting>
I have 2 pets.
The name of my dog is 'Max'.
The name of my cat is 'Tiger'.
</programlisting>
		</section>
		<section>
			<title>Structs</title>
			<para>A struct is an object which can hold a collection of variables and functions. A function inside a struct can access the other members of the same struct.
			</para>
			<bridgehead>Basic layout</bridgehead>
			<para>
			A simple example of struct usage:
			</para>
			<programlisting language="c">
SCENE main {
	/* Define a new struct type with two variables and one function */
	struct person {
		string name;
		int age;

		public int init(string _name, int _age) {
			name = _name;
			age = _age;
		};
		public int print() {
			echo "$name is $age years old\n";
		};
	};

	/* Create an instance of the struct and call the init()-function */
	person author-&gt;init("Atle", 25);

	/* Print the struct */
	author->print();

	/* Output of this program:
Atle is 25 years old
	*/
}
</programlisting>
			<para>To access members of a struct, we use the element selection operator <code>-&gt;</code> .
			The members we access from the outside must be marked with <code>public</code>.
			An error will ble issued if you attempt to access a variable or function which is not public.
			Members can optionally be preceeded with the <code>private</code> keyword.</para>
			<bridgehead>Constructors and destructors</bridgehead>
			<para>You may specify constructor- and destructor functions for structs.
			The constructor is always called at the location where an instance of a struct is declared.
			The destructor is called when the struct goes out of scope (when the block in which it is defined ends).</para>
			<para>Constructors are typically used to initialize member variables of structs to make sure they always are ready for use.
			Destructors are used to cleanup or flush data when the object is not going to be used anymore.</para>
			<para>Constructors can take arguments just like other functions.
			If you define arguments in a constructor, you have to call the constuctor with the same arguments at declaration.</para>
			<para>The syntax for constructors and destructors is borrowed from C++.
			The constructor function is defined without any type, and its name must be the same as the structs name.
			The destructor is declared the same way, only with a tilde <code>~</code> in front of the name.
			You cannot return values from constructors and destructors, they are <code>void</code> functions.</para>
			<para>As of now, you can only have one constructor per struct.</para>
			<para>A struct with a constructor and destructor can look like this:
			<programlisting language="c">
SCENE main {
	/* Struct with constructor and destructor */
	struct ctor_dtor {
		int value;

		/* Constructor with one argument */
		ctor_dtor (int _value) {
			value = _value;
			echo "C-tor called, value was $value\n";
		};

		/* Destructor for the struct */
		~ctor_dtor () {
			echo "D-tor called, value was $value\n";
		};
	};

	/* Declare an instance of struct 'ctor_dtor' and call the constructor */
	ctor_dtor cd_a(1);

	/* The destructor is magically called here, where the block ends */
}
</programlisting>
			</para>
		</section>
		<section>
			<title>Data types GET, POST and ENV</title>
			<para>P* provides three data types which implicitly retrieve data from the environment they run in, usually the web server.
			The data is parsed and stored the first time you use one of them.</para>
			<bridgehead>GET</bridgehead>
			<para>
			The GET-type reads the environment variables <code>QUERY_STRING</code>, which contains the query string from the user like <code>?id=45</code>. The GET-type is accessed just like a hash, but if you access an element which was not defined in the query string, the value will be boolean false.
			</para>
			<para>
			You can use the <code>defined</code> operator to check if a value is set or not.
			</para>
			<para>
			If P* doesn't find the <code>QUERY_STRING</code> environment variable, it will crash your program, but an empty query string is OK. You may have multiple GET-variables in your program, but P* will parse the query string once for every instance.
			</para>
			<para>
			Here is an example of usage of the <code>GET</code>-type.
			</para>
			<programlisting language="c">
SCENE main {
	/*
	   Before running this test, you need to set a query string in the terminal manually like this:
	   export QUERY_STRING="a&amp;b=B+is+a+string+value&amp;d=First+D&amp;d=Second+D"
	 */

	/* Instantiate the get object */
	GET get;

	/* Create an array of keys to look for */
	array&lt;string&gt; keys_to_check;
	keys_to_check[0] = "a";
	keys_to_check[1] = "b";
	keys_to_check[2] = "c";
	keys_to_check[3] = "d";

	/* Iterate the array of keys and check the keys in the GET object */
	int i = 0;
	while (i &lt; @keys_to_check) {
		string key = keys_to_check[i];

		/* Check if the key is defined */
		if (defined get[key]) {
			echo "The key '$key' is set in the query string\n";
			echo "\tThere are " . @get[key] . " instances of this key\n";
			if (@get[key] &gt; 1) {
				int j = 0;
				while (j &lt; @get[key]) {
					get[key][j];
					echo "\tThe value of '$key' instance number $j is '" . get[key][j] . "'\n";
					j++;
				}
			}
			else {
				echo "\tThe only value of '$key' is '" . *get[key] . "'\n";
			}
		}
		else {
			echo "Could not find key '$key' in the query string\n";
		}
		echo "\n";
		i++;
	}
}
</programlisting>
			<para>This program will output</para>
			<programlisting>
The key 'a' is set in the query string
There are 1 instances of this key
The only value of 'a' is 'true'

The key 'b' is set in the query string
There are 1 instances of this key
The only value of 'b' is 'B is a string value'

Could not find key 'c' in the query string

The key 'd' is set in the query string
There are 2 instances of this key
The value of 'd' instance number 0 is 'First D'
The value of 'd' instance number 1 is 'Second D'
</programlisting>
			<bridgehead>POST</bridgehead>
			<para>
			The <code>POST</code>-type is used exactly the same way as <code>GET</code>, but since it reads from standard intput, you can only have one instance.
			You can use both <code>POST</code> and <code>GET</code> at the same time.
			<bridgehead>ENV</bridgehead>
			</para>
			<para>
			The <code>ENV</code>-type provides the element selection operator <code>-&gt;</code> to access different environment variables.
			Variables are not cached, and <code>getenv(3)</code> is used to read environment variables every time you access them.
			P* will crash your program if you access a variable which doesn't exist. To avoid this, you should use the <code>defined</code>-operator to check for existence of variables.
			</para>
			<para>
			Example with the <code>ENV</code> type:
			</para>
			<programlisting language="c">
SCENE main {
	ENV env;
	echo "The current path is '" . env->PATH . "'\n";
}
</programlisting>
			<para>This program will output something like</para>
			<programlisting>
The current path is '/usr/local/bin:/usr/bin:/bin:/usr/test/bin/'
</programlisting>
		</section>
		<section>
			<title>HTML templates </title>
			<para>With P*, you don't need any external template engine. Templates are in-language!</para>
			<para>Templates look like blocks and are defined in the main scope of the program. When a template is called, it inherits all variables available from the location of the call.</para>
			<para>Inside templates, you can use the special syntax <code>{@variable}</code> to interpolate variables. 
			Actually, everything inside <code>{@ }</code> is parsed as an expression, and you can do anything here which you could do elsewhere in the program except for declaring variables.
			</para>
			<bridgehead>Example of a program using a HTML template</bridgehead>
			<programlisting language="c">
HTML_TEMPLATE document {
	&lt;!DOCTYPE HTML&gt;
	&lt;html&gt;
	&lt;head&gt;
	&lt;title&gt;{@title}&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
	&lt;/html&gt;
}

SCENE main {
	string title = "P* Web Programming Language test page";

	#CONTENT_TYPE text/html;
	#HTML_TEMPLATE document;
}
</programlisting>
			<para>In the above example, the template <code>document</code> is calledby a fixed string.
			If you store the name of the template which should be used in a variable, you can use the <code>@</code> to parse it as an expression instead.
			</para>
			<programlisting language="c">
HTML_TEMPLATE test_template {
	Test output
}

HTML_TEMPLATE test_template_again {
	Test output again
}

SCENE main {
	array&lt;string&gt; names;
	names[0] = "test_template";
	names[1] = "test_template_again";

	/* Loop the array with the two template names */
	int i = 0;
	while (i &lt; @names) {
		#HTML_TEMPLATE @names[i];
		i++;
	}
	return 0;
}
</programlisting>
			<bridgehead>Conditional blocks</bridgehead>
			<para><emphasis>LOOP and CONDITION blocks removed in pstar-1.2~alpha10</emphasis></para>
			<para>You can use <code>if</code>, <code>while</code>, <code>for</code> and <code>foreach</code> blocks to control the flow of the HTML template.
			The blocks work in the same way as elsewhere in the program, only that they contain text to be printed and not P* code.
			</para>
			<para>Here is an example program which loops an array of struct to print out all its data.
			Note that we use and <code>if</code> block to check if the array <code>rows</code> contains any elements at all by using the count operator <code>@</code>.
			If there are some values in it, we proceed with printing a table by looping the array in a <code>foreach</code> loop. Inside the loop, we call another template, <code>template_row</code> which contains the layout of the table row.
			</para>
			
				<programlisting language="c">
/* Object we use to hold some data */
struct row {
	public int id;
	public string description;
	row (int _id, string _description) {
		id = _id;
		description = _description;
	};
};

HTML_TEMPLATE template_row_header {
	&lt;th&gt;ID&lt;/th&gt;
	&lt;th&gt;Description&lt;/th&gt;
}
HTML_TEMPLATE template_row {
	&lt;td&gt;{@row-&gt;id}&lt;/td&gt;
	&lt;td&gt;{@row-&gt;description}&lt;/td&gt;
}

HTML_TEMPLATE document {
	&lt;!DOCTYPE HTML&gt;
	&lt;html&gt;
	&lt;head&gt;
	&lt;title&gt;{@title}&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
{@if (@rows > 0)
	&lt;p&gt;We have rows to print!&lt;/p&gt;
	&lt;table&gt;
		&lt;tr&gt;
			{@#HTML_TEMPLATE template_row_header}
		&lt;/tr&gt;
	{@foreach (auto row; rows)
		&lt;tr id="{@row-&gt;id}"&gt;{@#HTML_TEMPLATE template_row}&lt;/tr&gt;
	}
	&lt;/table&gt;
} else {
	&lt;p&gt;We do not have any rows to print&lt;/p&gt;
}
	&lt;/body&gt;
	&lt;/html&gt;
}

SCENE main {
	string title = "P* Web Programmin Language test page";

	array&lt;row&gt; rows;

	rows[@rows](1, "First row");
	rows[@rows](2, "Second row");
	rows[@rows](3, "Third row");

	#CONTENT_TYPE text/html;
	#HTML_TEMPLATE document;
}
</programlisting>
			<bridgehead>AJAX output</bridgehead>
			<para>
			P* supports common AJAX-operations like replacing text inside a &lt;div&gt;. If you want to output a variable interpolated into the template, the id-tag of the previous element in you HTML is used as variable name when the JSON is generated. In the example below, a jQuery scripts does this job. 
			</para>
			<para>
			You can also have P* generate JSON output for you.
			You can choose variables to output from a template, and P* will create a key/value pair to output to the browser.
			The key is taken from the expression block (<code>{@ ... }</code> preceeded by the text "id=" from where in the template the variable was.
			You may call another template or function inside that expression if you wish, everything inside will be JSON encoded into a variable named after the ID parameter.
			</para>
			<para>
			Under follows an example which outputs a variable using JSON if the GET-variable <code>do_ajax</code> is set.
			</para>
			<programlisting language="c">
HTML_TEMPLATE document {
	&lt;!DOCTYPE HTML&gt;
	&lt;html&gt;
	&lt;head&gt;
	&lt;title&gt;P* Web Programming Language&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;h1 id="{@"header"}"&gt;{@header_text}&lt;/h1&gt;
	&lt;h2 id="{@"subheader"}"&gt;{@subheader_text}&lt;/h2&gt;
	&lt;/body&gt;
	&lt;/html&gt;
}

SCENE fullpage {
	#CONTENT_TYPE text/html;
	#HTML_TEMPLATE document;
}

SCENE json {
	#JSON_BEGIN;
	/* Call the template "document" and print the
	expression inside the tag with id "header" and "subheader" */
	#HTML_TEMPLATE_VAR document "header", "subheader";
	#JSON_END;
}

SCENE config {
	public GET get;
	public string header_text = "This is the header";
	public string subheader_text = "This is the useless subheader";
}

/* The main scene extends the config-scene which 
   we use to set some variables. */
SCENE main : config {
	if (defined get["do_ajax"]) {
		/* Call the json scene */
		#SCENE json;
	}
	else {
		/* Call the fullpage scene */
		#SCENE fullpaga;
	}
}
</programlisting> 
			<para>Output of program when "do_ajax" is not set</para>
			<programlisting language="c">
Content-type: text/html;

&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;P* Web Programming Language&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 id="header"&gt;This is the header&lt;/h1&gt;
&lt;h2 id="header"&gt;This is the useless subheader&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
</programlisting>
			<para>Output of program when "do_ajax" is set</para>
			<programlisting language="c">
Content-type: application/json

{
	"header": "This is the header",
	"subheader": "This is the useless subheader",
	"": ""
}
</programlisting>
			<bridgehead>Output templates as JSON variables</bridgehead>
			<para>To output a whole template as a JSON variable, you can use the <code>#HTML_TEMPLATE_AS_VAR template_name</code>-pragma.
			The JSON variable name is set to be the same as the name of the template.
			This output method is useful if you want to output larger parts of a page.
			</para>
			<programlisting language="c">
HTML_TEMPLATE head {
	&lt;!DOCTYPE html&gt;
	&lt;html&gt;
	&lt;head&gt;
	&lt;title&gt;P* template as var output test&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;div id="body"&gt;
}

HTML_TEMPLATE foot {
	&lt;/div&gt;
	&lt;/body&gt;
	&lt;/html&gt;
}

HTML_TEMPLATE body {
	This is the body
}

SCENE json {
	/* Print the whole body as a JSON variable */
	#JSON_BEGIN;
	#HTML_TEMPLATE_AS_VAR body;
	#JSON_END;
}

SCENE fullpage {
	#CONTENT_TYPE text/html;
	#HTML_TEMPLATE head;
	#HTML_TEMPLATE body;
	#HTML_TEMPLATE foot;
}

SCENE main {
	GET get;
	if (defined get["do_ajax"]) {
		#SCENE json;
	}
	else {
		#SCENE fullpage;
	}
}
</programlisting>
			<para>Output of program when "do_ajax" GET variable is not set</para>
			<programlisting language="c">
Content-type: text/html;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;P* template as var output test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="body"&gt;
This is the body
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</programlisting>
			<para>Output with the "do_ajax" GET variable set</para>
			<programlisting language="c">
Content-type: application/json

{
	"body": "\tThis is the body\n",
			"": ""
}
</programlisting>
		</section>
		<section>
			<title>MySQL</title>
			<para>Boilerplate code is equal copies of code that you have to repeat many times in a program to make it work.
			This includes stuff like checking return values from library functions and printing error messages, or to including modules and header files at the top of a program.
			</para>
			<bridgehead>MySQL prepared statements in Java</bridgehead>
			<para>One of the worst time-consuming copy-paste-editing you will ever come over is creating a prepared statement.
			Under follows an example in the Java-language (which is copy-pasted-edited from some page found on Google).
			Notice that the word <code>PreparedStatement</code> is used seven times, and that you have to deal with the member methods <code>setString</code> and <code>setInt</code> of this object for every single variable.
			</para>
			<programlisting language="java">
Class.forName("com.mysql.jdbc.Driver");
connect = DriverManager.getConnection("jdbc:mysql://localhost/animal_kingdom?" + "user=dog&amp;password=i_hate_cats");

// It is extremely boring work to set all this fields
preparedStatement = connect.prepareStatement("INSERT INTO animal_kingdom.persons VALUES (?,?,?,?,?)");
preparedStatement.setString(1, "Jo");
preparedStatement.setString(2, "Lene");
preparedStatement.setString(3, "jolene@hotmail.com");

// Sometimes we need to store strange properties of a person
preparedStatement.setInt(4, 135);
preparedStatement.setInt(5, 4);
preparedStatement.executeUpdate();
</programlisting>
			<para>You begin to wonder why on earth you have to tell Java that "Jo" is a string type.
			You also have the manual work of counting all the question marks and setting the variables in correct order.
			This work, of course, becomes really fun when you also have to deal with column names in the query and you have 20 columns of different types to insert.
			</para>
			<para>The P* author, also referred to as 'someone' in this article, has once been forced to write a wrapper class just to keep track of column names, values and question marks.
			We don't want to spend time doing this, we want to create web pages! Let's have some more meat.
			</para>
			<bridgehead>MySQL prepared statements in P*</bridgehead>
			<emphasis>The Windows build of P* does not yet support MySQL</emphasis>
			<para>Next comes the same example in P*, lets just specify the variables first instead of inlining, like you would normally do:
			<programlisting language="c">

string name = "Jo";
string surname = "Lene";
string email = "jolene@hotmail.com";
int weight = 135;   /* In kilograms */
int width = 4;      /* In feet */

SQL sql {
	INSERT INTO animal_kingdom.persons VALUES (
		{@name}, {@surname}, {@email}, {@weight}, {@width}
	)
}

MYSQL mysql->connect("localhost", "dog", "i_hate_cats");
mysql->select_db("animal_kingdom");

MYSQL_STMT stmt = mysql->new_statement();
stmt->prepare(sql);
stmt->execute();
</programlisting>
			</para>
			<bridgehead>Common reactions to this example</bridgehead>
			<itemizedlist spacing="normal" mark="bullet"> 
			<listitem>Wait a minute...You said you wouldn't inline the variables, but you did?
			</listitem>
			<listitem>You idiot!!! This is SQL -- IN -- JEC -- TION -- !!!!
			</listitem>
			</itemizedlist>
			<bridgehead>Counter-strike</bridgehead>
			<para>This way of specifying a prepared statement is P* magic.
			We would not normally, and shouln't either, put variables inside the SQL-string.
			However, because we are lazy (and to avoid the horrible and error-prone code you see in the first example), we might be tempted to do just that.
			With P* you can put the variables inside the SQL-string WITHOUT them being concatenated.
			</para>
			<para>The whole SQL-object is a chain of strings and value pointers, and P* does the dirty work of passing each variable to MySQL with the correct type set.
			The variables are replaced with question marks before passed to MySQL, making it look like the Java-example.
			</para>
		</section>
		<section>
			<title>File I/O</title>
			<para>P* provides a unique way of handling reading and writing files.
			With maximum simplicity you can go through a file line by line and edit, delete or insert new lines.
			You do not need to worry about joining strings together in the correct order or storing the file temporarily, P* will do that for you.
			</para>
			<bridgehead>The FILE type</bridgehead>
			<para>The FILE type is the main filehandle, used to open and close files. Files may be opened read-only, read/write and may be truncated.
			Here is the syntax for the different open methods.
			</para>
			<programlisting language="c">
SCENE main {
	FILE file;

	/* Open a file read-only */
	if (!file->open_ro("my_file")) {
		errcho "Could not open my_file: " . file->error() . "\n";
		return 1;
	}
	file->close();

	/* Open a file for reading and writing */
	if (!file->open_rw("my_file")) {
		errcho "Could not open my_file: " . file->error() . "\n";
		return 1;
	}
	file->close();

	/* Open a file read-write and truncate it on open */
	if (!file->open_truncate("my_file")) {
		errcho "Could not open my_file: " . file->error() . "\n";
		return 1;
	}
	file->close();

	return 0;
}
</programlisting>
	<bridgehead>The LINE type</bridgehead>
			<para>The LINE type is used to read a file line by line and to modify it.
			The LINE does not work on its own, and has to be bound to a FILE object like this:
			<programlisting language="c">
LINE line = file;
</programlisting>
			Initially, the line does not point to any particular position in the FILE.
			To make it point to the first line, use the <code>++</code>-operator like this:
			<programlisting language="c">
LINE line = file;
line++;
</programlisting>
			The LINE object now points to the first line of the file.
			If the file is empty, it points to the beginning.
			</para>
			<para>
			The <code>++</code> operator returns the number of bytes read into the LINE object.
			This can be used in a loop to break the loop when it reaches the last line.
			<programlisting language="c">
LINE line = file;
while (line++) {
	echo "Found a line: $line\n";
}
</programlisting>
			Trailing newlines (<code>\n</code>) are not removed when lines are read in.
			</para>
			<para>You can make a LINE object point to the end of a file by using <code>line = file->end()</code>, which is useful for appending to files.
			</para>
			<para>The LINE object can also traverse a file line by line in reverse order, using the <code>line--</code>-operator. The LINE object will point to the previous line from the current position.
			When no more lines can be read, the LINE object will point to the beginning of the file, but it will not contain any data.</para>
	<bridgehead>Edit files using the LINE object</bridgehead>
			<para>
			It's possible to edit a file using the LINE object by setting it's value to something else.
			The changes then have to be queued for update in the FILE object using the syntax <code>file->update(line);</code>.
			After you've added all the changes, they must be written out using <code>file->flush()</code>.
			</para>
			<para>
			Here is an example which adds a <code>#</code> at the beginning of lines which have numbers in them.
			<programlisting language="c">
SCENE main {
	FILE file;

	/* Open a file read-write, we will modify it */
	if (!file->open_rw("my_file")) {
		errcho "Could not open my_file: " . file->error() . "\n";
		return 1;
	}

	/* Initialize some variables */
	LINE line = file;

	int lines = 0;
	int modified = 0;

	/* Loop through all lines of the file */
	while (line++) {
		lines++;

		/* Check if the line contains numbers and does not already begin with a # */
		if (line =~ /\d/ &amp;&amp; line !~ /^#/) {
			/* Add the # to the line */
			line = "# $line";

			/* Queue the updated LINE object for writing */
			file->update(line);

			modified++;
		}
	}

	/* Print out some stats */
	echo "Modified $modified of total $lines lines.\n";

	/* Write the changes out and close the file */
	file->flush();
	file->close();

	return 0;
}
</programlisting>
			</para>
			<para>If you need to write to an empty file, just write all your data to the LINE object right after the <code>line++</code>-operation. You can also use <code>line = file->begin()</code>, the result will be the same.
			You can insert or append new lines to a file by adding data to the LINE objects at desired locations. Original data will be overwritten.
			</para>
		</section>
		<section>
			<title>Pointers</title>
			<para>A pointer is a type which doesn't hold a value itself. Instead, it "points to" another value.
			If you are familiar with any C-like language, you are (hopefully) well aware of why pointers are nice, and you also know that they can be dangerous.
			In P*, pointers are not dangerous, and errors you make are detected without having programs crashing badly.
			</para>
			<para>Let's begin with an example.
			We want to pass a value into a function, and the function should do something with it.
			We do not, however, want the value to be copied as we want to keep the result. This is how you could do it without pointers:</para>
			<programlisting language="c">
SCENE main {
	int move_to_neighbour(int i) {
		return i + 1;
	}

	int my_house_number = 134;

	/* Gives 134 */
	echo "I live in house number $my_house_number\n";

	my_house_number = move_to_neighbour(134);

	/* Gives 135 */
	echo "I have now moved, and live with my neighbour in number $my_house_number\n";
}
</programlisting>
			<para>Easy or what? No need for pointers here. But what if we want to modify two values?
			A function can only return one value, so this might be a problem.
			But what if we put the values into an array?
			Surely a function can return an array with many values.
			</para>
			<bridgehead>The stupid example</bridgehead>
			<programlisting language="c">
SCENE main {
	array&lt;int&gt; move_to_neighbour(array&lt;int&gt; values) {
		values[0] += 1;
		values[1] += 100;

		return values;
	}

	int my_house_number = 134;
	int my_phone_number = 5550453;

	/* Gives 134 and 5550453 */
	echo "I live in house number $my_house_number\n";
	echo "My phone number is $my_phone_number\n";

	array&lt;int&gt; my_info;
	my_house_number, my_phone_number =&gt; my_info;

	my_info = move_to_neighbour(my_info);

	my_house_number = my_info[0];
	my_phone_number = my_info[1];

	/* Gives 135 and 5550553 */
	echo "After moving, I live in house number $my_house_number\n";
	echo "After moving, my phone number is $my_phone_number\n";
}
</programlisting>
			<para>OK, let's state that this works, but the readability is horrendous.</para>
			<bridgehead>The big example</bridgehead>
			<para>What we need is pointers!
			Code with pointers in have strange stuff in it, like <code>&amp;</code>, <code>&lt;int&gt;</code> and <code>*</code>
			</para>
<programlisting language="c">
SCENE main {
	void move_to_neighbour(pointer&lt;int&gt; house_number, pointer&lt;int&gt; phone_number) {
		*house_number += 1;
		*phone_number += 100;
	}

	int my_house_number = 134;
	int my_phone_number = 5550453;

	/* Gives 134 and 5550453 */
	echo "I live in house number $my_house_number\n";
	echo "My phone number is $my_phone_number\n";

	move_to_neighbour (&amp;my_house_number, &amp;my_phone_number);

	/* Gives 135 and 5550553 */
	echo "After moving, I live in house number $my_house_number\n";
	echo "After moving, my phone number is $my_phone_number\n";
}
</programlisting>
			<bridgehead>A narrow-down</bridgehead>
			<para>So, what's really going on here? Let us first talk about how a pointer is used in an easier example.</para>
<programlisting language="c">
SCENE main {
	int my_value = 1;
	pointer&lt;int&gt; my_pointer = &amp;my_value;
	echo "The value is " . *my_pointer . "\n";
}
</programlisting>
			<para>We first declare an <code>int</code> value called <code>my_value</code> and assign the value <code>1</code> to it.
			Pointers are template types, that means that they can only point to values of one type.
			You choose this type by putting it's name between <code>&lt;</code> and <code>&gt;</code>.
			In theory, the pointers wouldn't have to only work with one type, but we do this to help prevent programming mistakes.</para>
			<para>Then, we have the <code>&amp;my_value</code> statement. The <code>&amp;</code> is an operator which we in P* call <emphasis>pointer to</emphasis>. 
			This operator can be used on most values, and it tells the value to create a new pointer which points to itself.
			Then we assign this new pointer with <code>=</code> to our <code>my_pointer</code> variable.
			</para>
			<para>Now, <code>my_pointer</code> holds a pointer to <code>my_value</code>, and to convert it back, the pointer supports an operator with a lovely name: The <emphasis>indirection</emphasis> operator <code>*</code>.
			If you have the pointer, and wishes to use the value it's pointing to, you must always add the <code>*</code> in front of it, like we do here when we print the value out.
			</para>
			<para>In the big example, the function <code>move_to_neighbour</code> takes two pointers to integers and modifies the values they point to.
			When we call the function, we add <code>&amp;</code> in front of the variable names to convert them to pointers to match what the function expects to receive.
			</para>
		<bridgehead>Now some object orientation!</bridgehead>
		<para>The example we've just gone through doesn't take advantage of the object orientation in P*.
		It works since we've only keeping track of two values, phone- and house number, but what if there were 20 different values?
		We would need to have 20 arguments in our move_to_neighbour function, and at the same time keep track of 20 different variables in our main program block.
		To clean up mess like this, we create an object, a <code>struct</code>, to stash our stuff into. Read more about structs in the Structs-section of the documentation.
		</para>
		<programlisting language="c">
SCENE main {
	/* Define a struct wich can hold contact info for someone */
	struct contact_info {
		/* These variables are only visible inside this struct */
		int house_number;
		int phone_number;
		string street;

		/* The constructor which sets the initial values */
		contact_info (int a, int b, string c) {
			house_number = a;
			phone_number = b;
			street = c;
		};

		/* The function which modifies the values. No arguments! */
		public void move_to_neighbour() {
			house_number += 1;
			phone_number += 100;
		};

		/* Print out the values, still no arguments needed. */
		public void print_info() {
			echo "- Street is $street\n";
			echo "- House number $house_number\n";
			echo "- Phone number is $phone_number\n";
		};
	};

	/* Create an instance of the struct 'contact_info' and
	   call the constructor to set my information */
	contact_info my_info(134, 5550453, "Sesame Street");

	/* Call the print function of the struct, gives 134 and 5550453 */
	echo "This was my contact info before i moved:\n";
	my_info->print_info();

	/* Call the move function to move to our neighbour */
	my_info->move_to_neighbour();

	/* Tell the struct to print the values one more time,
	   it should give out 135 and 5550553 */
	echo "This is where i live now:\n";
	my_info->print_info();
}
		</programlisting>
		<para>But now the pointers are gone again! Does this mean that we don't need them after all?
		If we only hold the contact info for a single person, this example works pretty well.
		But what if there were five persons which were moving? Or ANY number of persons?
		</para>
		<para>Let's first create an array to hold contact info for may persons, arrays should always be used for cases like this.
		Not that arrays are template types just as pointers, and we create and array here to hold values of the type <code>contact_info</code>
		</para>
		<programlisting langauge="c">
array&lt;contact_info&gt; neighbourhood_info;
		</programlisting>
		<para>Now, let's have some people moving to our neighbourhood:</para>
		<programlisting langauge="c">
/* The '@contact_info' returns the size of the array. The first time we
   use it, the size is zero, so we set the 0'th element to the person
   who lives in Blue Street. The next time the size is 1, because we
   just added a value, so the Polar Bear drive-person is added to this
   slot, and so on. */
neighbourhood_info[@neighbourhood_info](2, 5551000, "Blue street");
neighbourhood_info[@neighbourhood_info](34, 5552000, "Polar Bear drive");
neighbourhood_info[@neighbourhood_info](56, 5553000, "Mountain road");
neighbourhood_info[@neighbourhood_info](78, 5554000, "Apple close");
		</programlisting>
		<para>What happens now, is that ALL the four persons have to move to their neighbours due to a flood.
		To do an operation many times, we use a loop to iterate through the array.
		Here, all loops are possible to use, but the easiest way is to use a <code>foreach</code> loop with a pointer.
		</para>
		<programlisting language="c">
/* Declare a pointer to some value of the type 'contact_info' */
pointer&lt;contact_info&gt; iterator;

/* The foreach loop will run multiple times, and for each run, it will
   put a new value into our pointer called 'iterator' beginning with 
   the first one. */
foreach (iterator; neighbourhood_info) {
	/* Call the move function on a person. Remember the star!!! */
	*iterator->move_to_neighbour();
}
		</programlisting>
		<para>Now, all persons have moved. We didn't have to use a pointer in the <code>foreach</code> loop, but not without issues. Let's see the alternative first before we smash it to pieces:</para>

		<programlisting language="c">
/* Declare a temporary variable used in the foreach loop. The asterisk, *,
   tells P* that we shouldn't call any constructor for this variable,
   we don't need that since we'll be overwriting it in the loop anyway. */
contact_info *temp;

foreach (temp; neighbourhood_info) {
	temp->move_to_neighbour();
}
		</programlisting>
		<para>What happens here, is that for every iteration of the loop, a value from our neighbourhood array is <emphasis>COPIED</emphasis> into the temporary variable.
		When we then call the move function, the temporary value gets modified, but the original value stays unchanged, and the person doesn't move to it's neighbour.
		</para>
		<para>The other advantage of using pointers when we pass structs around to functions, is that we prevent the struct from being copied.
		Copying structs in P* uses much more CPU and memory on your box than pointers. Pointers also use less memory than default types like <code>int</code>, but since copying an <code>int</code> is very fast, it's usually OK to keep the program readable and skip the pointers if we don't need them.</para>
		<para>Let's put in the full example, with structs, arrays and pointers, for you to copy-paste and play with:</para>
		<programlisting language="c">
SCENE main {
	/* Define a struct wich can hold contact info for someone */
	struct contact_info {
		int house_number;
		int phone_number;
		string street;

		/* Constructor for this struct, set's all the values */
		contact_info (int a, int b, string c) {
			house_number = a;
			phone_number = b;
			street = c;
		};

		/* Function to move to the neighbours */
		public void move_to_neighbour() {
			house_number += 1;
			phone_number += 100;
		};

		/* Print out the content of this struct in a readable form */
		public void print_info() {
			echo "- Person lives in $street number $house_number with tel. $phone_number\n";
		};
	};

	/* Declare an array to hold contact info of many persons */
	array&lt;contact_info&gt; neighbourhood_info;

	/* Construct contact info for four persons and put this into an array */
	neighbourhood_info[@neighbourhood_info](2, 5551000, "Blue street");
	neighbourhood_info[@neighbourhood_info](34, 5552000, "Polar Bear drive");
	neighbourhood_info[@neighbourhood_info](56, 5553000, "Mountain road");
	neighbourhood_info[@neighbourhood_info](78, 5554000, "Apple close");

	/* Declare a temporary variable used in the foreach loop */
	contact_info *temp;

	foreach (temp; neighbourhood_info) {
		temp-&gt;move_to_neighbour();
	}

	/* Let's verify that no move really happened, since we used a temporary variable. */
	echo "Result after attempting to move using a temporary variable, no change has happened:\n";
	foreach (temp; neighbourhood_info) {
		temp-&gt;print_info();
	}

	/* Do the moving the proper way, now with a pointer */
	pointer&lt;contact_info&gt; iterator;

	/* The foreach loop will run multiple times, and for each run, it will
	   put a new value into our pointer called 'iterator' beginning with
	   the first one. */
	foreach (iterator; neighbourhood_info) {
		/* Call the move function on a person. Remember the star!!! */
		*iterator-&gt;move_to_neighbour();
	}

	/* Make sure that the moving occured. */
	echo "\nResult after moving using pointer:\n";
	foreach (iterator; neighbourhood_info) {
		*iterator-&gt;print_info();
	}
}
		</programlisting>
		</section>
	</chapter>
	<chapter>
		<title>Development</title>
		<emphasis>Read this if you like to write stuff!</emphasis>
		<section>
			<title>How it's run</title>
			<para>
			A session is divided into parsing and running. P* parses the input file and creates a hierarchy of all objects which exis in the code. Variables, functions and types are registered into <code>namespace</code>s of each block.
			</para>
			<para>
			At run time, every object holds <code>state</code> objects for their children.
			These nests, and the first state is held outside the program structure.
			The states are created on the first run of each element.
			</para>
			<para>
			If you call a function from two different locations, the function gets one state for each place it is called from.
			If you nest function calls, one state is created for each nested call.
			If you call the nested function again the same way, it re-uses the states from the last call.
			This saves memory allocations.
			</para>
			<para>
			Some objects are also <code>namespace sessions</code>, like blocks. These hold variables during run-time.
			The variables are copied from the original namespace (created on parse-time) the first time the block is called from a specific location.
			This method allows the same program to run threaded on the same object structure, as no objects created on parsing are in any way changed when the program runs. When run as a web server module, this method is ideal, as most of the work with initializing a program is only done once.
			</para>
			<para>
			It should also be easy to implement threading in P*.
			</para>
		</section>
		<section>
			<title>Speed</title>
			<para>Of course, since many things in P* happen behind the scenes, it runs slower than if you had written the same program in C and compiled it.
			P*, however, strives to keep this overhead to a minimum.
			It must also be said that the author of P* is extremely lazy, and the codebase is therefore quite small and efficient.
			</para>
			<para>
			A test run of a PHP "Hello World!"-program run 100 times took 1.5 seconds. On the same box, P* did it in 0.4 seconds. This however only tells us that P* parses the source and initializes faster than PHP. PHP does other things faster, like running of expressions.
			</para>
			<para>
			A small program in P* does ~300 memory allocations, while PHP does 18 000.
			There is no current measurement of performance with the P* web server module, but the I/O performance is at least average.
			</para>
			<para>
			The expression running in P* is not omptimized very much yet, but on my home computer, it can run a short expression in a loop (like <code>i++</code>) 50 million times in about 3 seconds. This should be fast enough for now.
			</para>
		</section>
		<section>
			<title>Important functionality to-be-written</title>
			<para>
			Help with development is needed! Please consider joining in or submitting code. <email>atle@goliathdns.no</email>
			</para>
			<para>
			<table>
				<title>List of future functionality</title>
				<tgroup cols="2">
				<colspec colname="c1"/>
				<colspec colname="c2"/>
				<thead>
					<row>
						<entry>Function</entry>
						<entry>Status</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Perl-like in-language regular expressions</entry>
						<entry>Replacement and matching now possible</entry>
					</row>
					<row>
						<entry>HTTP Cookies</entry>
						<entry>Not written</entry>
					</row>
					<row>
						<entry>Character sets</entry>
						<entry>P* is currently only safe with UTF-8</entry>
					</row>
					<row>
						<entry>Database</entry>
						<entry>P* currently only supports simple MySQL prepared statements, run unbuffered</entry>
					</row>
					<row>
						<entry>Apache module</entry>
						<entry>Now working, might need more enhancements.</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
			</para>
		</section>
	</chapter>
</book>
