<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../docbook-xml-4.5/docbookx.dtd">

<book>
	<title>The P* Web Programming Language</title>
	<chapter>
		<title>Introduction</title>
		<section>
			<title>Logo</title>
			<mediaobject>
			<imageobject>
			<imagedata fileref="images/logo.png"/>
			</imageobject>
			<textobject>
			<phrase>
			</phrase>
			</textobject>
			</mediaobject>
		</section>
		<section>
			<title>What is P*?</title>
			<para>P* (P-star) is a shortname for "Web P* Language". It is unknown what the "P" actually stands for, so a star is used to indicate that any word starting with a "P" may be used. It does not mean that the name can be any number of P's. Oh, by the way, the word has to relate to computers. If you didn't think about any non-computer P-word, you're in the target audience of this article.
			</para>
			<para>P* is a computer programming language specifically designed to make web progamming easy by incorporating frequent operations into the language. P* uses a C-like syntax, so it would be easy to begin using if you have ever used C, C#, C++, Java, Perl, PHP and many others. P* is also highly inspired from some of these languages, and tries to implement the best of them while also using completely new methods for solving different programming tasks.
			</para>
			<para>P* is run as a script by its interpreter, which is written in C++. It is currently under development so if you have any suggestions for new features, shout out now! Also feel free to write new features and send them in.
			</para>
			<para>
			P* is free software and is currently licenced with GPLv3 <ulink>http://www.gnu.org/copyleft/gpl.html</ulink>
			</para>
			<para>
				This docbook is written by Atle Solbakken <email>atle@goliathdns.no</email>
			</para>
		</section>
		<section>
			<title>Mailing lists</title>
			<para>
			<email>p-star-users@googlegroups.com</email> - Mailing list for help and general discussion
			</para>
			<para>
			<email>p-star-dev@googlegroups.com</email> - Mailing list for development
			</para>
		</section>
		<section>
			<title>We want meat!</title>
			<para>This is the official "Hello World!" example of P* program:
			<programlisting language="c">
#!/usr/bin/wpl -f
SCENE main {
	echo "Hello World!\n";
}
			</programlisting>
			</para>
			<para>
			To build and run P*, you need to have the libraries and development packages of mysql-client and mimetic. You also need autotools installed. This is how you download and build P* using your favourite shell:
			</para>
			<programlisting language="shell">
git clone https://github.com/atlesn/P-star.git
cd P-star
autoreconf -i
./configure
make install
			</programlisting>
			<para>
			You should specify an alternative directory to install P* in so that you can easily remove it later.
			This is done by adding <code>prefix=my_directory</code> when running configure, like <code>./configure --prefix=/usr/test</code>. The files will then be placed in /usr/test/bin and /usr/test/lib.
			</para>
			<para>
			To run P* when you have specified an alternative install path, you should run this first:
			</para>
			<programlisting language="shell">
export LD_LIBRARY_PATH=/usr/test/lib
export PATH=$PATH:/usr/test/bin
			</programlisting>
			<para>
			Then the fun part: Create a file named <code>my_program.pstar</code> and paste in the text from the Hello-World example above.
			Then do this to run the program:
			</para>
			<programlisting language="shell">
wpl -f my_program.pstar
			</programlisting>
		</section>
		<section>
			<title>Why Another Language?</title>
			<para>You might think that if someone decides to begin on the huge task of designing a new programming language, that someone has probably gone crazy.
			And you're spot on. Years of fierce fighting with different programming languages can drive the most well-composed person mad (this 'someone' we refer to here has never been well-composed, but if he was before he started programming, he would certeinly have lost that property by now).
			</para>
			<para>P* tries to simplify tasks like HTML templates and database handling, where most languages use procedural and error-prone methods. P* introduces completely new methods of making life easier when dealing with this.
			</para>
		</section>
	</chapter>
	<chapter>
		<title>Get P*!</title>
		<para>
		The source of P* is currently available
<ulink url="https://github.com/atlesn/P-star">from Github</ulink>.
		</para>
		<para>
		<code>$ git clone https://github.com/atlesn/P-star.git</code>
		</para>
		<para>
		You can also <ulink url="http://www.p-star.org/dox/html/">browse the source code</ulink>
		</para>
	</chapter>		
	<chapter>
		<title>The P* language</title>
		<para>All programming languages have advantages and disanvantages. These two creatures are happily married, and they can't be separated. If you try to kill a disadvantage, it's beloved advantage will commit suicide, and you're back where you started. If you overlap a disadvantage with another advantage, a new disadvantage comes along with it.
		</para>
		<para>
		Does this mean that we will never have a perfect programming lanuage?
		It probably does.
		However, P* has made an attempt to get around this by selecting which bad things to have first and seeing what advantages we get with those afterwards.
		</para>
		<para>A P* program is run by an interpreter engine, and this is bad for speed.
		We compensate for that by making the language simple, which actually has the side effect of making it suitable for web programming.
		What web programming is about is, yes you guessed correct, "web", and the tools to create the web should be designed with that in mind.
		</para>
		<section>
			<title>Basic program layout and scenes</title>
			<para>All code in P* programs sits inside <code>SCENE</code> blocks.
			A program is required to provide a <code>SCENE</code> called <code>main</code>, which is the first one to be run by the interpreter.
			P* will crash with an error message if the <code>SCENE main</code> is missing.
			There may be no duplicate scene names, and they cannot nest.
			</para>
			<para>
			Scenes, apart from the <code>main</code> scene are called using the <code>#SCENE</code>-pragma.
			A scene may access all variables from it's caller.
			</para>
			<para>A simple P* program with two scenes might look like this:
			</para>
			<programlisting language="c">
#!/usr/bin/wpl -f
SCENE my_scene {
	/* Print out the value of the 'text'-variable */
	echo "This is my_scene: '$text'\n";
}

SCENE main {
	/* Create a string variable */
	string text = "Hello world!";

	/* Call the other scene */
	#SCENE my_scene;
}
/* This program will output
This is my_scene: 'Hello world!'
*/
			</programlisting>
		</section>
		<section>
			<title>Basic types</title>
			<para>One important element of making a program efficient, is to use correct types for your variables.
			When you've programmed for a while, type selection becomes natural, and you don't think much about it.
			</para>
			<para>Some languages try to help the user by using automatic types.
			This is supposed to make it easier to write.
			P* does allow implicit converting between primitive types, but no variables can be typeless.
			</para>
			<para>It is not much work to write <code>int</code> or <code>string</code> in front of a variable.
			A good thing about this is that it helps make programs more readable, and it's an easy way for developers to make programs efficient.
			</para>
			<para>Variables in P* are stored in memory as their C/C++ equalient type. Size of the type depends on the platform the interpreter is compiled on.
			</para>
			<table>
				<title>List of P* primitive types</title>
				<tgroup cols="3">
				<colspec colname="c1"/>
				<colspec colname="c2"/>
				<colspec colname="c3"/>
				<thead>
					<row>
						<entry>Name</entry>
						<entry>Description</entry>
						<entry>Example</entry>
						<entry>C-equalient</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>int</entry>
						<entry>Signed integer</entry>
						<entry>int a = "-10";</entry>
						<entry>long int</entry>
					</row>
					<row>
						<entry>uint</entry>
						<entry>Unsigned integer</entry>
						<entry>uint a = 10;</entry>
						<entry>long unsigned int</entry>
					</row>
					<row>
						<entry>llint</entry>
						<entry>Long long signed integer</entry>
						<entry>llint a = "-10";</entry>
						<entry>long long int</entry>
					</row>
					<row>
						<entry>lluint</entry>
						<entry>Long long unsigned integer</entry>
						<entry>lluint a = 10;</entry>
						<entry>long long unsigned int</entry>
					</row>
					<row>
						<entry>float</entry>
						<entry>Single precision floating point</entry>
						<entry>float a = "2.00003";</entry>
						<entry>float</entry>
					</row>
					<row>
						<entry>double</entry>
						<entry>Double precision floating point</entry>
						<entry>double a = "2.00003";</entry>
						<entry>double</entry>
					</row>
					<row>
						<entry>bool</entry>
						<entry>Boolean true or false (1 or 0)</entry>
						<entry>bool a = 1;</entry>
						<entry>bool</entry>
					</row>
					<row>
						<entry>string</entry>
						<entry>String value</entry>
						<entry>string text = "P* Web Programming Language";</entry>
						<entry>Uses <code>&lt;string&gt;</code> from C++</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
			<bridgehead>Example of usage of different data types</bridgehead>
			<programlisting language="c">
SCENE main {
	int base = 2;
	int exp = 1;
	int exp_max = 20;
	lluint result = 1;

	while (exp &lt;= exp_max) {
		result *= base;
		echo "$base exp $exp is $result\n";
		exp++;
	}

}

/* This program will output: 
2 exp 1 is 2
2 exp 2 is 4
2 exp 3 is 8
2 exp 4 is 16
2 exp 5 is 32
2 exp 6 is 64
2 exp 7 is 128
2 exp 8 is 256
2 exp 9 is 512
2 exp 10 is 1024
2 exp 11 is 2048
2 exp 12 is 4096
2 exp 13 is 8192
2 exp 14 is 16384
2 exp 15 is 32768
2 exp 16 is 65536
2 exp 17 is 131072
2 exp 18 is 262144
2 exp 19 is 524288
2 exp 20 is 1048576
*/
			</programlisting>
			</section>
			<section>
			<title>Strings</title>
			<para>P* supports defining strings inside the double quote <code>"</code> or single quote <code>'</code>.
			</para>
			<para>P* allows you to interpolate variables inside a text string delimited by double quotes. A variable to be interpolated is prefixed with the dollar sign, <code>$</code>.
			The string output operators <code>echo</code> and <code>errcho</code> internally use the C++ <code>iostream</code> output methods <code>cout</code> and <code>cerr</code>.
			</para>
			<para>In P*, you can concatenate string using the dot operator, <code>.</code>.
			</para>
			<para>
			A double quote delimited string supports the following replacement escape sequences:
			</para>
			<table>
				<title>List of double quote escape sequences</title>
				<tgroup cols="2">
				<colspec colname="c1"/>
				<colspec colname="c2"/>
				<thead>
					<row>
						<entry>Sequence</entry>
						<entry>Is replaced with</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>\0</entry>
						<entry>A NULL character</entry>
					</row>
					<row>
						<entry>\a</entry>
						<entry>ASCII code 7, BEL (bell)</entry>
					</row>
					<row>
						<entry>\b</entry>
						<entry>ASCII code 8, BS (backspace)</entry>
					</row>
					<row>
						<entry>\t</entry>
						<entry>ASCII code 9, TAB (horizontal tab)</entry>
					</row>
					<row>
						<entry>\n</entry>
						<entry>ASCII code 10, LF (newline)</entry>
					</row>
					<row>
						<entry>\v</entry>
						<entry>ASCII code 11, VT (vertical tab)</entry>
					</row>
					<row>
						<entry>\r</entry>
						<entry>ASCII code 13, CR (carriage return)</entry>
					</row>
					<row>
						<entry>\"</entry>
						<entry>ASCII code 34, " (double quotes)</entry>
					</row>
					<row>
						<entry>\\</entry>
						<entry>ASCII code 92, \ (backslash)</entry>
					</row>
					<row>
						<entry>\$</entry>
						<entry>ASCII code 36, $ (dollar sign)</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
			<para>
			P* will issue an error if you use a double quote escape sequence which is not defined. Single quotes only support the escape sequence <code>\'</code>, and all other sequences with backslash are interpreted literally without any errors.
			</para>
			<bridgehead>Example of string usage</bridgehead>
			<programlisting language="c">
SCENE main {
	int num = 2;

	echo "The number is $num\n";
	echo 'The number is $num\n';
}
/* This program will output:
The number is 2
The number is $num\n
*/
			</programlisting>
		</section>
			<section>
			<title>Regular expressions</title>
			<para>P* have adopted the neat and simple regular expression syntax from the Perl language. Regular expression are delimeted with slashes. Here is an example of a program which uses regular expressions:</para>
			<programlisting language="c">
SCENE main {
	/* Create a strange string */
	string test = "aaa   bbbb";

	/* Check if a regular expression matches */
	if (test =~ /a\s*b/) {
		echo "Does match\n";
	}

	/* Check if a regular expression does not match */
	if (test !~ /ffff/) {
		echo "Does not match\n";
	}
}
			</programlisting>
			<para>Take a look at to the <ulink url="http://perldoc.perl.org/perlre.html">Perl documentation for regular expressions</ulink> for more information.</para>
			<para>Not that P* by now only supports simple matching like in the example above. Modifiers like <code>/g</code>, replace prefix <code>s/</code> and variable interpolation is not yet supported.</para>
		</section>
		<section>
			<title>Functions</title>
			<para>The P* function syntax is equal to that of the C-language. A function needs to have a return value of a specific type.
			A function may have zero or more arguments. Functions do not inherit variables from the caller. Functions need to have unique names, function overloading is currently not supported. Functions need to be defined inside scenes.
			</para>
			<para>
			Variables passed into a function are usually copied (pass-by-value). Some objects however, like MySQL-objects, are implicitly passed as reference instead (pass-by-reference). The documentation of these special types tells you which are passed by reference.
			</para>
			<para>
			Primitive data types like <code>int</code> and <code>string</code> are implicity converted between each other to mach the function arguments (weak type checking).
			</para>
			<para>
			In the example below, we have a function with return type of <code>int</code> called <code>sum</code>.
			This function takes two integer arguments and returns their sum.
			We pass in a string as the second argument to show that it is implicitly converted into an integer when passed into the function.
			</para>
			<programlisting language="c">
SCENE main {
	/* Define a function which takes two integer arguments */
	int sum(int a, int b) {
		echo "Adding number $a and $b\n";
		return a + b;
	}

	/* Declare an integer variable 'result' */
	int result;

	/* Call the sum-function and put the result into the 'result'-variable */
	/* The string "3" is implicitly converted into an integer */
	result = sum(1, "3");

	echo "The result is $result\n";
}
/* This program will output
Adding number 1 and 3
The result is 4
*/

			</programlisting>
		</section>
		<section>
			<title>Scene inheritance</title>
			<para>A scene can extend another scene. This is useful for instance if we want to put configuration stuff inside a scene and include it in other scenes.
			</para>
			<para>In a scene inheritance setup, we can use the keywords <code>private</code> and <code>protected</code> to restrict access to variables and functions.
			If we don't specify any keyword, private is assumed.
			</para>
			<para>A variable or function which is private can only be accessed from within the same scene, but protected ones can be accessed from derived scenes.
			</para>
			<para>Base scenes are specified by putting a colon <code>:</code> after the scene name followed by a comma separated list of the base scenes, like <code>SCENE main : b, c</code>. Base scenes are run prior to the derived scene in the order in which they are defined.
			</para>
			<para>The example below has a total of four scenes which inherits from each other.
			The main scene inherits from scene <code>b</code> and <code>c</code>, which makes them base scenes of main.
			Scene <code>b</code> inherits further from scene <code>a</code>, and the order of execution of all the scenes will be <code>a -> b -> c -> main</code>
			</para>
			<para>If we call a function of a base scene from a derived scene, the function can access private variables of the scene in which it is defined.
			</para>
			<programlisting language="c">
SCENE a {
	echo "This is A\n";
}

SCENE b : a {
	echo "This is B\n";

	/* This variable is private, and can only be accessed from within b */
	int var_b = 1;

	/* This function is protected, and can be accessed from derived scenes */
	protected int b_function(int argument) {
		echo "This is B's function:\n";

		/* The function can access the private variable var_b */
		echo "\tvar_b is " . var_b . "\n";
	}
}

SCENE c {
	/* This variable is protected, and can be accessed from derived scenes */
	protected int var_c = 2;

	echo "This is C: var_c is " . var_c . "\n";
}

SCENE main : b, c {
	/* Here, the protected variable var_c is accessed */
	echo "This is Main: var_c is " . var_c . "\n";

	/* Call the protected function b_function */
	b_function();
}

			</programlisting>
			<para>When this program is run, it will output:</para>
			<programlisting>
This is A
This is B
This is C: var_c is 2
This is Main: var_c is 2
This is B's function:
	var_b is 1
			</programlisting>
		</section>
		<section>
			<title>Expressions and operators</title>
			<para>P* have mostly adapted operators and their precedence from the C-language.
			The basics of the expression syntax is also the same as in C.
			Expressions are run right to left.
			Most operators are mapped directly to their C-equalient, and behave the same way.
			</para>
			<para>The associativity for an operator decides the return value of the expression.
			In the example below, we see that the return value of the expression is different depending on which variable we have on the left side of the <code>+</code> operator.</para>
			<programlisting language="c">
SCENE main {
	int a = 10;
	float b = "1.5";

	/* The expression a + b will return an integer */
	echo "Integer result: " . (a + b) . "\n";

	/* The expression b + a will return a float */
	echo "Float result: " . (b + a) . "\n";
}
/* This program will output:
Integer result: 11
Float result: 11.500000
*/

			</programlisting>
			<table>
				<title>Operators in P*</title>
				<tgroup cols="2">
				<colspec colname="c1" align="center" />
				<colspec colname="c2" align="center" />
				<colspec colname="c3"/>
				<colspec colname="c4" align="center" />
				<colspec colname="c5"/>
				<thead>
					<row>
						<entry>Precedence</entry>
						<entry>Operator</entry>
						<entry>Description</entry>
						<entry>Associativity</entry>
						<entry>Example</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry morerows="7">2</entry>
						<entry>()</entry>
						<entry>Function call</entry>
						<entry>Left or none</entry>
						<entry>call(2,3) (expands to call 2, 3 ())</entry>
					</row>
					<row>
						<entry>[]</entry>
						<entry>Array subscription (hashes and arrays)</entry>
						<entry morerows="3">Left</entry>
						<entry>my_array[2] (expands to my_array 2 [])</entry>
					</row>
					<row>
						<entry>-&gt;</entry>
						<entry>Element selection (structs and classes)</entry>
						<entry>my_struct-&gt;variable (expands to my_struct variable -&gt;)</entry>
					</row>
					<row>
						<entry>++</entry>
						<entry>Postfix increment</entry>
						<entry>i++</entry>
					</row>
					<row>
						<entry>--</entry>
						<entry>Postfix decrement</entry>
						<entry>i--</entry>
					</row>
					<row>
						<entry>*</entry>
						<entry>First element selector (arrays)</entry>
						<entry morerows="2">Right</entry>
						<entry>*my_array</entry>
					</row>
					<row>
						<entry>@</entry>
						<entry>Element counter (arrays and hashes)</entry>
						<entry>@my_array</entry>
					</row>
					<row>
						<entry>isempty</entry>
						<entry>Empty check logic (strings)</entry>
						<entry>isempty my_string</entry>
					</row>
					<row>
						<entry morerows="3">3</entry>
						<entry>++</entry>
						<entry>Prefix increment</entry>
						<entry morerows="3">Right</entry>
						<entry>++i</entry>
					</row>
					<row>
						<entry>--</entry>
						<entry>Prefix decrement</entry>
						<entry>--i</entry>
					</row>
					<row>
						<entry>~</entry>
						<entry>Bitwise not</entry>
						<entry>~invert_this</entry>
					</row>
					<row>
						<entry>!</entry>
						<entry>Logical not</entry>
						<entry>!var</entry>
					</row>
					<row>
						<entry morerows="1">4</entry>
						<entry>=~</entry>
						<entry>Pattern match</entry>
						<entry morerows="1">Left</entry>
						<entry>a =~ /regular expression/</entry>
					</row>
					<row>
						<entry>!~</entry>
						<entry>Pattern negative match</entry>
						<entry>a !~ /regular expression/</entry>
					</row>
					<row>
						<entry morerows="2">5</entry>
						<entry>*</entry>
						<entry>Multiplication</entry>
						<entry morerows="5">Left</entry>
						<entry>a*b</entry>
					</row>
					<row>
						<entry>/</entry>
						<entry>Division</entry>
						<entry>a/b</entry>
					</row>
					<row>
						<entry>%</entry>
						<entry>Modulus</entry>
						<entry>a%b</entry>
					</row>
					<row>
						<entry morerows="2">6</entry>
						<entry>+</entry>
						<entry>Sum</entry>
						<entry>a+b</entry>
					</row>
					<row>
						<entry>-</entry>
						<entry>Subtraction</entry>
						<entry>a-b</entry>
					</row>
					<row>
						<entry>.</entry>
						<entry>String concatenation</entry>
						<entry>a . b</entry>
					</row>
					<row>
						<entry morerows="1">7</entry>
						<entry>&lt;&lt;</entry>
						<entry>Left bitshift</entry>
						<entry morerows="1">Left</entry>
						<entry>a &lt;&lt; 1</entry>
					</row>
					<row>
						<entry>&gt;&gt;</entry>
						<entry>Right bitshift</entry>
						<entry>a &gt;&gt; 1</entry>
					</row>
					<row>
						<entry>8</entry>
						<entry>&amp;</entry>
						<entry>Bitwise AND</entry>
						<entry morerows="2">Left</entry>
						<entry>a &amp; b</entry>
					</row>
					<row>
						<entry>9</entry>
						<entry>^</entry>
						<entry>Bitwise XOR</entry>
						<entry>a ^ b</entry>
					</row>
					<row>
						<entry>10</entry>
						<entry>|</entry>
						<entry>Bitwise OR</entry>
						<entry>a | b</entry>
					</row>
					<row>
						<entry morerows="3">11</entry>
						<entry>&lt;=</entry>
						<entry>Logical less than or equal</entry>
						<entry morerows="5">Left</entry>
						<entry>a &lt;= b</entry>
					</row>
					<row>
						<entry>&gt;=</entry>
						<entry>Logical more than or equal</entry>
						<entry>a &gt;= b</entry>
					</row>
					<row>
						<entry>&lt;</entry>
						<entry>Logical less than</entry>
						<entry>a &lt; b</entry>
					</row>
					<row>
						<entry>&gt;</entry>
						<entry>Logical more than</entry>
						<entry>a &gt; b</entry>
					</row>
					<row>
						<entry morerows="1">12</entry>
						<entry>==</entry>
						<entry>Logical equal</entry>
						<entry>a == b</entry>
					</row>
					<row>
						<entry>!=</entry>
						<entry>Logical not equal</entry>
						<entry>a != b</entry>
					</row>
					<row>
						<entry>13</entry>
						<entry>&amp;&amp;</entry>
						<entry>Logical AND</entry>
						<entry morerows="1">Left</entry>
						<entry>a &amp;&amp; b</entry>
					</row>
					<row>
						<entry>14</entry>
						<entry>||</entry>
						<entry>Logical OR</entry>
						<entry>a || b</entry>
					</row>
					<row>
						<entry>15</entry>
						<entry>=></entry>
						<entry>Push discard chain to array</entry>
						<entry>Right</entry>
						<entry>10, 20, 30 => my_array</entry>
					</row>
					<row>
						<entry morerows="11">16</entry>
						<entry>=</entry>
						<entry>Assign</entry>
						<entry morerows="11">Left</entry>
						<entry>a = b</entry>
					</row>
					<row>
						<entry>+=</entry>
						<entry>Assign by sum</entry>
						<entry>a += b</entry>
					</row>
					<row>
						<entry>-=</entry>
						<entry>Assign by difference</entry>
						<entry>a -= b</entry>
					</row>
					<row>
						<entry>*=</entry>
						<entry>Assign by product</entry>
						<entry>a *= b</entry>
					</row>
					<row>
						<entry>/=</entry>
						<entry>Assign by quotient</entry>
						<entry>a /= b</entry>
					</row>
					<row>
						<entry>%=</entry>
						<entry>Assign by remainder</entry>
						<entry>a %= b</entry>
					</row>
					<row>
						<entry>&amp;=</entry>
						<entry>Assign by bitwise AND</entry>
						<entry>a &amp;= b</entry>
					</row>
					<row>
						<entry>^=</entry>
						<entry>Assign by bitwise XOR</entry>
						<entry>a ^= b</entry>
					</row>
					<row>
						<entry>|=</entry>
						<entry>Assign by bitwise OR</entry>
						<entry>a |= b</entry>
					</row>
					<row>
						<entry>&lt;&lt;=</entry>
						<entry>Assign by bitwise left shift</entry>
						<entry>a &lt;&lt;= b</entry>
					</row>
					<row>
						<entry>&gt;&gt;=</entry>
						<entry>Assign by bitwise right shift</entry>
						<entry>a &gt;&gt;= b</entry>
					</row>
					<row>
						<entry>.=</entry>
						<entry>Append to string</entry>
						<entry>a .= b</entry>
					</row>
					<row>
						<entry>18</entry>
						<entry>,</entry>
						<entry>Discard operator (comma)</entry>
						<entry>Left</entry>
						<entry>a, b</entry>
					</row>
					<row>
						<entry morerows="1">19</entry>
						<entry>echo</entry>
						<entry>Write expression to standard output</entry>
						<entry morerows="1">Right</entry>
						<entry>echo "Hello world!"</entry>
					</row>
					<row>
						<entry>errcho</entry>
						<entry>Write expression to standard error</entry>
						<entry>errcho "This is an error message"</entry>
					</row>
					<row>
						<entry morerows="1">20</entry>
						<entry>break</entry>
						<entry>Break out from nearest loop</entry>
						<entry>None</entry>
						<entry>break</entry>
					</row>
					<row>
						<entry>return</entry>
						<entry>Return from nearest function</entry>
						<entry>Right</entry>
						<entry>return 1</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
		</section>
		<section>
			<title>Hashes and arrays</title>
			<para>P* supports dynamic sized hashes and arrays. These are template types and can only hold values of the type you specify.
			They can hold any type, including arrays and hashes. This is useful for creating more dimensions.
			An element is created the first time you access it, and the value will be initialized to the type's default value (numbers are 0, strings are empty etc.).</para>
			<bridgehead>array&lt;default type&gt;</bridgehead>
			<para>The array is a list of elements stored in sequential order and access by an index number. 
			Here is an example of an array:
			</para>
			<programlisting language="c">
/* Instantiate an array of type int, no elements are created */
array&lt;int&gt; my_first_array;

/* Set the first three elements of the array to 10, 20 and 30 */
my_first_array[0] = 10;
my_first_array[1] = 20;
my_first_array[2] = 30;

/* Iterate the array and print its values */
int i = 0;
while (i &lt; @my_first_array) {
	echo "The value of element $i is " . my_first_array[i] . "\n";
	i++;
}

/* Output of this program:
The value of element 0 is 10
The value of element 1 is 20
The value of element 2 is 30
*/
			</programlisting>
			<para>
			Arrays support the special operators "first element selection" <code>*</code> and "element counter" <code>@</code>. These are used like this:
			</para>
			<programlisting language="c">
/* Instantiate an array of type string, no elements are created */
array&lt;string&gt; my_first_array;

/* Set the value of two elements */
my_first_array[0] = "First element";
my_first_array[1] = "Second element";

/* Count the number of values and print to standard output */
echo "The array has " . @my_first_array . " elements\n";

/* Get the first element and print to standard output */
echo "The value of the first array element is '" . *my_first_array . "'\n";

/* Output of this program:
The array has 2 elements
The value of the first array element is 'First element'
 */
			</programlisting>
			<para>
			The array only creates elements you access. If you skip indexes, like if you only use element 0 and 5, the size of the array will be 6, but memory is not allocated for elements 1-4.
			</para>
			<para>You can push a list to the end of an array using a combination of the discard operator <code>,</code>(comma) and the discard save operator <code>=></code>. The discard save operator returns the number of elements added to the array. Here is an example program:</para>
			<programlisting language="c">
SCENE main {
	/* Instantiate and array */
	array&lt;int&gt; my_array;

	/* Push the four numbers into the array */
	int count = (10, 20, "30", 40 => my_array);

	/* Print result */
	echo "Pushed $count values to the array\n";

	int i = "-1";
	while (++i &lt; @my_array) {
		echo "my_array[$i] is " . my_array[i] . "\n";
	}
}

/* This program will output:

   Pushed 4 values to the array
   my_array[0] is 10
   my_array[1] is 20
   my_array[2] is 30
   my_array[3] is 40

 */

			</programlisting>
			<bridgehead>hash&lt;default type&gt;</bridgehead>
			<para>
			A hash is an array except that the values are accessed using string identifiers instead of indexes and that elements are unordered.
			You can use the counter operator <code>@</code> for hashes the same way as for arrays.
			An element of a hash is created the first time you access it.
			</para>
			<para>
			Here is an example program using hashes:
			</para>
			<programlisting language="c">
hash&lt;string&gt; my_pets;

/* Set the two values of the hash */
my_pets["dog"] = "Max";
my_pets["cat"] = "Tiger";

/* Create an array of the keys */
array&lt;string&gt; pet_keys;
pet_keys[0] = "dog";
pet_keys[1] = "cat";

/* Count the elements of the hash and print to standard output */
echo "I have " . @my_pets . " pets.\n";

/* Iterate the array of the keys and print the values of the hash */
int i = 0;
while (i &gt; @pet_keys) {
	echo "The name of my " . pet_keys[i] . " is '" . my_pets[pet_keys[i]] . "'.\n";
	i++;
}

/* This program will output:
I have 2 pets.
The name of my dog is 'Max'.
The name of my cat is 'Tiger'.
*/
			</programlisting>
		</section>
		<section>
			<title>Structs</title>
			<para>A struct is an object which can hold a collection of variables and functions. A function inside a struct can access the other members of the same struct.
			</para>
			<para>
			A definition of a struct can look like this.
			</para>
			<programlisting language="c">
SCENE main {
	/* Define a new struct type with two variables and one function */
	struct person {
		string name;
		int age;

		int print() {
			echo "$name is $age years old\n";
		}
	};

	/* Create an instance of the struct */
	person author;

	/* Set the variables in the struct */
	author->age = 25;
	author->name = "Atle";
	author->print();
}
/* Output of this program:
Atle is 25 years old
*/
			</programlisting>
			<emphasis>
			Structs in P* will later be extended with class-functionality to allow object oriented programming. The struct type will continue having all types public by default.
			</emphasis>
		</section>
		<section>
			<title>Data types GET, POST and ENV</title>
			<para>P* provides three data types which implicitly retrieve data from the environment they run in, usually the web server.
			The data is parsed and stored the first time you use one of them.</para>
			<bridgehead>GET</bridgehead>
			<para>
			The GET-type reads the environment variables <code>QUERY_STRING</code>, which contains the query string from the user like <code>?id=45</code>. The GET-type is accessed just like a hash, but if you access an element which was not defined in the query string, the value will be boolean false.
			</para>
			<para>
			If a key is set in the query string but without a value, it will be set as boolean true. All other values are set to be strings.
			</para>
			<para>
			If P* doesn't find the <code>QUERY_STRING</code> environment variable, it will crash your program, but an empty query string is OK. You may have multiple GET-variables in your program, but P* will parse the query string once for every instance.
			</para>
			<para>
			Here is an example of usage of the <code>GET</code>-type.
			</para>
			<programlisting language="c">
SCENE main {
	/*
	   Before running this test, you need to set a query string in the terminal manually like this:
	   export QUERY_STRING="a&amp;b=B+is+a+string+value&amp;d=First+D&amp;d=Second+D"
	 */

	/* Instantiate the get object */
	GET get;

	/* Create an array of keys to look for */
	array&lt;string&gt; keys_to_check;
	keys_to_check[0] = "a";
	keys_to_check[1] = "b";
	keys_to_check[2] = "c";
	keys_to_check[3] = "d";

	/* Iterate the array of keys and check the keys in the GET object */
	int i = 0;
	while (i &lt; @keys_to_check) {
		string key = keys_to_check[i];

		/* Check if the key is defined */
		if (*get[key]) {
			echo "The key '$key' is set in the query string\n";
			echo "\tThere are " . @get[key] . " instances of this key\n";
			if (@get[key] &gt; 1) {
				int j = 0;
				while (j &lt; @get[key]) {
					get[key][j];
					echo "\tThe value of '$key' instance number $j is '" . get[key][j] . "'\n";
					j++;
				}
			}
			else {
				echo "\tThe only value of '$key' is '" . *get[key] . "'\n";
			}
		}
		else {
			echo "Could not find key '$key' in the query string\n";
		}
		echo "\n";
		i++;
	}
}

/* This program will output:

The key 'a' is set in the query string
There are 1 instances of this key
The only value of 'a' is 'true'

The key 'b' is set in the query string
There are 1 instances of this key
The only value of 'b' is 'B is a string value'

Could not find key 'c' in the query string

The key 'd' is set in the query string
There are 2 instances of this key
The value of 'd' instance number 0 is 'First D'
The value of 'd' instance number 1 is 'Second D'

*/
			</programlisting>
			<bridgehead>POST</bridgehead>
			<para>
			The <code>POST</code>-type is used exactly the same way as <code>GET</code>, but since it reads from standard intput, you can only have one instance.
			You can use both <code>POST</code> and <code>GET</code> at the same time.
			<bridgehead>ENV</bridgehead>
			</para>
			<para>
			The <code>ENV</code>-type provides the element selection operator <code>-&gt;</code> to access different environment variables.
			Variables are not cached, and <code>getenv(3)</code> is used to read environment variables every time you access them.
			P* will crash your program if you access a variable which is not defined.
			</para>
			<para>
			Example with the <code>ENV</code> type:
			</para>
			<programlisting language="c">
SCENE main {
	ENV env;
	echo "The current path is '" . env->PATH . "'\n";
}

/* This program will output something similar to:
The current path is '/usr/local/bin:/usr/bin:/bin:/usr/test/bin/'
*/
			</programlisting>
		</section>
		<section>
			<title>HTML templates in P*</title>
			<para>With P*, you don't need any external template engine. Templates are in-language!</para>
			<para>Templates look like blocks and are defined in the main scope of the program. When a template is called, it inherits all variables available from the location of the call.</para>
			<para>Inside templates, you can use the special syntax <code>{@variable}</code> to interpolate variables.
			You can also use while loops with the syntax <code>{@LOOP (expression) text}</code>
			</para>
			<bridgehead>Example of a program using a HTML template</bridgehead>
			<programlisting language="c">
HTML_TEMPLATE document {
	&lt;!DOCTYPE HTML&gt;
	&lt;html&gt;
	&lt;head&gt;
	&lt;title&gt;{@title}&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
	&lt;/html&gt;
}

SCENE main {
	string title = "P* Web Programming Language test page";

	#CONTENT_TYPE text/html;
	#HTML_TEMPLATE document;
}
			</programlisting>
			<para>In the above example, the template <code>document</code> is called statically, the name is resolved and validated at parse-time. You can also store the name of the template in a variable an call it dynamically using the expression-starter <code>@</code> at run-time like this:
			<programlisting language="c">
HTML_TEMPLATE test_template {
	Test output
}

HTML_TEMPLATE test_template_again {
	Test output again
}

SCENE main {
	array&lt;string&gt; names;
	names[0] = "test_template";
	names[1] = "test_template_again";

	/* Loop the array with the two template names */
	int i = 0;
	while (i &lt; @names) {
		#HTML_TEMPLATE @names[i];
		i++;
	}
	return 0;
}
			</programlisting>
			</para>
			<para>
			P* supports common AJAX-operations like replacing text inside a &lt;div&gt;. If you want to output a variable interpolated into the template, the id-tag of the previous element in you HTML is used as variable name when the JSON is generated. In the example below, a jQuery scripts does this job. 
			</para>
			<para>
			You can also have P* generate JSON output for you.
			You can choose variables to output from a template, and P* will create a key/value pair to output to the browser.
			The key is taken from the previous expression preceeded by the text "id=" from where in the template the variable was.
			Under follows an example which outputs a variable using JSON if the GET-variable <code>do_ajax</code> is set.
			</para>
			<bridgehead>Example program using templates and JSON output</bridgehead>
			<programlisting language="c">
HTML_TEMPLATE document {
	&lt;!DOCTYPE HTML&gt;
	&lt;html&gt;
	&lt;head&gt;
	&lt;title&gt;P* Web Programming Language&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;h1 id="{@"header"}"&gt;{@header}&lt;/h1&gt;
	&lt;/body&gt;
	&lt;/html&gt;
}

SCENE main {
	GET get;
	string header = "This is the header";
	if (*get["do_ajax"]) {
		#JSON_BEGIN;
		#HTML_TEMPLATE_VAR document header;
		#JSON_END;
	}
	else {
		#CONTENT_TYPE text/html;
		#HTML_TEMPLATE document;
	}
}
			</programlisting> 
			<bridgehead>Output of program when "do_ajax" is not set</bridgehead>
			<programlisting language="c">
Content-type: text/html;

&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;P* Web Programming Language&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 id="header"&gt;This is the header&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
			</programlisting>
			<bridgehead>Output of program when "do_ajax" is set</bridgehead>
			<programlisting language="c">
Content-type: application/json

{
	"header": "This is the header",
	"": ""
}
			</programlisting>
			<bridgehead>Output templates as JSON variables</bridgehead>
			<para>To output a whole template as a JSON variable, you can use the <code>#HTML_TEMPLATE_AS_VAR template_name</code>-pragma.
			The JSON variable name is set to be the same as the name of the template.
			This output method is useful if you want to output larger parts of a page.
			</para>
			<bridgehead>HTML_TEMPLATE_AS_VAR-Example</bridgehead>
			<programlisting language="c">
HTML_TEMPLATE head {
	&lt;!DOCTYPE html&gt;
	&lt;html&gt;
	&lt;head&gt;
	&lt;title&gt;P* template as var output test&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;div id="body"&gt;
}

HTML_TEMPLATE body {
	This is the body
}

HTML_TEMPLATE foot {
	&lt;/div&gt;
	&lt;/body&gt;
	&lt;/html&gt;
}

SCENE main {
	GET get;
	if (*get["do_ajax"]) {
		#JSON_BEGIN;
		#HTML_TEMPLATE_AS_VAR body;
		#JSON_END;
	}
	else {
		#CONTENT_TYPE text/html;
		#HTML_TEMPLATE head;
		#HTML_TEMPLATE body;
		#HTML_TEMPLATE foot;
	}
}
			</programlisting>
			<bridgehead>Output of program when "do_ajax" GET variable is not set</bridgehead>
			<programlisting language="c">
Content-type: text/html;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;P* template as var output test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="body"&gt;
This is the body
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
			</programlisting>
			<bridgehead>Output with the "do_ajax" GET variable set</bridgehead>
			<programlisting language="c">
Content-type: application/json

{
	"body": "\tThis is the body\n",
			"": ""
}
			</programlisting>
		</section>
		<section>
			<title>MySQL</title>
			<para>Boilerplate code is equal copies of code that you have to repeat many times in a program to make it work.
			This includes stuff like checking return values from library functions and printing error messages, or to including modules and header files at the top of a program.
			</para>
			<bridgehead>MySQL prepared statements in Java</bridgehead>
			<para>One of the worst time-consuming copy-paste-editing you will ever come over is creating a prepared statement.
			Under follows an example in the Java-language (which is copy-pasted-edited from some page found on Google).
			Notice that the word <code>PreparedStatement</code> is used seven times, and that you have to deal with the member methods <code>setString</code> and <code>setInt</code> of this object for every single variable.
			</para>
			<programlisting language="java">
Class.forName("com.mysql.jdbc.Driver");
connect = DriverManager.getConnection("jdbc:mysql://localhost/animal_kingdom?" + "user=dog&amp;password=i_hate_cats");

// It is extremely boring work to set all this fields
preparedStatement = connect.prepareStatement("INSERT INTO animal_kingdom.persons VALUES (?,?,?,?,?)");
preparedStatement.setString(1, "Jo");
preparedStatement.setString(2, "Lene");
preparedStatement.setString(3, "jolene@hotmail.com");

// Sometimes we need to store strange properties of a person
preparedStatement.setInt(4, 135);
preparedStatement.setInt(5, 4);
preparedStatement.executeUpdate();
			</programlisting>
			<para>You begin to wonder why on earth you have to tell Java that "Jo" is a string type.
			You also have the manual work of counting all the question marks and setting the variables in correct order.
			This work, of course, becomes really fun when you also have to deal with column names in the query and you have 20 columns of different types to insert.
			</para>
			<para>The P* author, also referred to as 'someone' in this article, has once been forced to write a wrapper class just to keep track of column names, values and question marks.
			We don't want to spend time doing this, we want to create web pages! Let's have some more meat.
			</para>
			<bridgehead>MySQL prepared statements in P*</bridgehead>
			<emphasis>The Windows build of P* does not yet support MySQL</emphasis>
			<para>Next comes the same example in P*, lets just specify the variables first instead of inlining, like you would normally do:
			<programlisting language="c">

string name = "Jo";
string surname = "Lene";
string email = "jolene@hotmail.com";
int weight = 135;   /* In kilograms */
int width = 4;      /* In feet */

SQL sql {
	INSERT INTO animal_kingdom.persons VALUES (
		{@name}, {@surname}, {@email}, {@weight}, {@width}
	)
}

MYSQL mysql->connect("localhost", "dog", "i_hate_cats");
mysql->select_db("animal_kingdom");

MYSQL_STATEMENT stmt = mysql->new_statement();
stmt->prepare(sql);
stmt->execute();
			</programlisting>
			</para>
			<bridgehead>Common reactions to this example</bridgehead>
			<itemizedlist spacing="normal" mark="bullet"> 
			<listitem>Wait a minute...You said you wouldn't inline the variables, but you did?
			</listitem>
			<listitem>You idiot!!! This is SQL -- IN -- JEC -- TION -- !!!!
			</listitem>
			</itemizedlist>
			<bridgehead>Counter-strike</bridgehead>
			<para>This way of specifying a prepared statement is P* magic.
			We would not normally, and shouln't either, put variables inside the SQL-string.
			However, because we are lazy (and to avoid the horrible and error-prone code you see in the first example), we might be tempted to do just that.
			With P* you can put the variables inside the SQL-string WITHOUT them being concatenated.
			</para>
			<para>The whole SQL-object is a chain of strings and value pointers, and P* does the dirty work of passing each variable to MySQL with the correct type set.
			The variables are replaced with question marks before passed to MySQL, making it look like the Java-example.
			</para>
		</section>
		<section>
			<title>Example of web-application</title>
			<para>Below is an example of a full web application which uses MySQL database, POST variables and HTML templates. The example uses a JavaScript to submit a form to the web server.
			The web server replies with JSON, and the JavaScript replaces the inner HTML of a DIV with the results.
			</para>
			<emphasis>This example has to be run on a web server as a CGI-script. You also need a MySQL database with a table with an 'id' column with unique ID-numbers and a 'text' column.</emphasis>
			<para><ulink url="http://www.p-star.org/cgi-bin/test">Here is a running version of the example program below</ulink>
			</para>
			<bridgehead>Content of file 'test_tmpl.pstar'</bridgehead>
			<programlisting language="c">
HTML_TEMPLATE test_template {
	&lt;!DOCTYPE html&gt;
	&lt;html&gt;
	&lt;head&gt;
	&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"&gt;
	&lt;/script&gt;
	&lt;script&gt;
	//  P* also supports application/x-www-form-urlencoded and the GET-method
	$(document).ready(function() {
		$("#my_form").on("submit", function(event) {
			event.preventDefault();

			var form_data = new FormData(this);
			$.ajax({
				url:            '?',
				type:           'POST',
				data:           form_data,
				mimeType:       "multipart/form-data",
				dataType:       'json',
				contentType:    false,
				cache:          false,
				processData:    false,
				success:        function(data, status, jqXHR) {
				$.each(data, function(key, val) {
					if (key!="") {
					$("#text_div").html(val);
					}
					});
				},
				error:          function(jqXHR, status, error_thrown) {

				}
			});
		});
	});
	&lt;/script&gt;
	&lt;style type="text/css"&gt;
	body {
		background-color: #eee;
	}
	form * {
		margin: 5px;
	}
	select {
		width: 100%;
	}
	option {
		overflow: hidden;
		margin: 0px;
	}
	#form_div {
		padding: 30px;
		width: 40%;
		margin: 0 auto;
		background: #aa0;
		text-align: center;
		border-radius: 10px;
	}
	#form_div span {
		font-weight: bold;
	}
	#result_parent {
		padding: 30px;
		width: 40%;
		margin: 0 auto;
		text-align: center;
		background-color: #fff;
		border-radius: 10px;
		margin-top: 10px;
	}
	#result_parent span {
		font-weight: bold;
	}
	#result_parent div {
		background-color: #ddd;
		border: 1px solid #000;
		margin-top: 30px;
		border-radius: 10px;
	}
	&lt;/style&gt;
	&lt;title&gt;My first P* web application&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;form id="my_form" method="POST" encoding="multipart/form-data"&gt;
	&lt;div id="form_div"&gt;
	&lt;span&gt;Please choose a string to retrieve from the database:&lt;/span&gt;
		&lt;select name="id" id="id_select"&gt;

	&lt;!-- This a P* template while-loop --&gt;

	{@LOOP (row++)
		&lt;option value="{@row["id"]}"&gt;{@row["text"]}&lt;/option&gt;
	}

	&lt;/select&gt;
	&lt;input type="submit"&gt;
	&lt;/div&gt;
	&lt;/form&gt;
	&lt;div id="result_parent"&gt;
	&lt;span&gt;The string is retrived with AJAX and printed out here:&lt;/span&gt;

	&lt;!-- This is P* variable interpolation --&gt;

	&lt;div id="{@"text_div"}"&gt;-{@text}&lt;/div&gt;

	&lt;/div&gt;
	&lt;/body&gt;
	&lt;/html&gt;
}

			</programlisting>
			<bridgehead>Content of the file 'test.pstar'</bridgehead>
			<programlisting language="c">
#!/usr/test/bin/wpl -f

#INCLUDE test_tmpl.pstar;

SCENE main {
	/* POST-data only, not GET */
	POST post;

	int id;
	/*
	   All variables from POST and GET are constructed as arrays,
	   independent of how many variables with equal names we have.
	   The star selects the first element.
	   */
	if (*post["id"]) {
		id = *post["id"];
	}

	MYSQL mysql;
	mysql->connect("127.0.0.1", "my_user_name", "my_password);
	mysql->select_db("my_database");
	MYSQL_STMT stmt = mysql->new_statement();

	/*
	   We need a table with one numeric id-column and one text-column. Put nice data in it
	*/
	SQL sql_all {
		SELECT * FROM variables GROUP BY(id)
	}
	SQL sql_single {
		SELECT * FROM variables WHERE id={@id}
	}

	/*
	   If the POST-variable 'id' is set, we limit the query
	   */
	if (id) {
		if (!stmt->prepare(sql_single)) {
			errcho "Could prepare query: " . mysql->error() . "\n";
		}
	}
	else {
		if (!stmt->prepare(sql_all)) {
			errcho "Could prepare query: " . mysql->error() . "\n";
		}
	}

	if (!stmt->execute()) {
		errcho "Could not execute query: " . mysql->error() . "\n";
	}

	MYSQL_ROW row = stmt->get_row_iterator();

	/*
	   If the POST-variable 'id' is set, we output JSON to the client!
	   */
	if (id) {
		string text = "(Not found)";
		if (row++) {
			text = row["text"];
		}
		#JSON_BEGIN;
		#HTML_TEMPLATE_VAR test_template text;
		#JSON_END;
	}
	else {
		#CONTENT_TYPE text/html;
		#HTML_TEMPLATE test_template;
	}
}
			</programlisting>
		</section>
	</chapter>
	<chapter>
		<title>P* project</title>
		<emphasis>Read this if you're into free software development!</emphasis>
		<section>
			<title>Project status</title>
			<para>
			The P*-project currently constist of only one person. For the language to be taken to the next level, help is needed!
			</para>
			<table>
				<title>List of project tasks</title>
				<tgroup cols="2">
				<colspec colname="c1"/>
				<colspec colname="c2"/>
				<thead>
					<row>
						<entry>Task</entry>
						<entry>Status</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Spread the word</entry>
						<entry>Currently in progress, but help needed.</entry>
					</row>
					<row>
						<entry>Documentation</entry>
						<entry>This document is the only documentation apart from the source code. Need more!</entry>
					</row>
					<row>
						<entry>Web-page / bug-tracking</entry>
						<entry>Help needed</entry>
					</row>
					<row>
						<entry>Testing</entry>
						<entry>Help is needed with writing production web pages in P* to find out what needs to be done</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
		</section>
	</chapter>
	<chapter>
		<title>Development</title>
		<emphasis>Read this if you like to write stuff!</emphasis>
		<section>
			<title>Status Quo</title>
			<para>The base of the P* interpreter is written in C++ and runs quite well.
			The development is still in an early phase, and there has been many rewrites of particularry the expression handling and value subsystem.
			A rewrite takes two days of writing and one or to days fixing compiling errors, so it gives a good feeling that this hasn't been needed for quite a while.
			</para>
			<para>
			The implementation of loadable modules, with MySQL as the first one out, can be done without any change to the base.
			This might indicate that things now are implemented in a reasonable way.
			</para>
		</section>
		<section>
			<title>How it's run</title>
			<para>
			A session is divided into parsing and running. P* parses the input file and creates a hierarchy of all objects which exis in the code. Variables, functions and types are registered into <code>namespace</code>s of each block.
			</para>
			<para>
			At run time, every object holds <code>state</code> objects for their children.
			These nests, and the first state is held outside the program structure.
			The states are created on the first run of each element.
			</para>
			<para>
			If you call a function from two different locations, the function gets one state for each place it is called from.
			If you nest function calls, one state is created for each nested call.
			If you call the nested function again the same way, it re-uses the states from the last call.
			This saves memory allocations.
			</para>
			<para>
			Some objects are also <code>namespace sessions</code>, like blocks. These hold variables during run-time.
			The variables are copied from the original namespace (created on parse-time) the first time the block is called from a specific location.
			This method allows the same program to run threaded on the same object structure, as no objects created on parsing are in any way changed when the program runs. When run as a web server module, this methos is ideal as most of the work with initializing a program is only done the first time.
			</para>
			<para>
			It should also be easy to implement threading in P*.
			</para>
		</section>
		<section>
			<title>Speed</title>
			<para>Of course, since many things in P* happen behind the scenes, it runs slower than if you had written the same program in C and compiled it.
			P*, however, strives to keep this overhead to a minimum.
			It must also be said that the author of P* is extremely lazy, and the codebase is therefore quite small and efficient.
			</para>
			<para>
			A test run of a PHP "Hello World!"-program run 100 times took 1.5 seconds. On the same box, P* did it in 0.4 seconds. This however only tells us that P* parses the source and initializes faster than PHP. PHP does other things faster, like running of expressions.
			</para>
			<para>
			A small program in P* does ~300 memory allocations, while PHP does 18 000.
			There is no current measurement of performance when P* is run as module in a web serverm, because no such module currently exists (but there will be one soon !).
			</para>
			<para>
			The expression running in P* is not omptimized very much yet, but on my home computer, it can run a short expression in a loop (like <code>i++</code>) 50 million times in about 3 seconds. This should be fast enough for now.
			</para>
		</section>
		<section>
			<title>Database handling</title>
			<para>
			The P* interpreter has custom C++ wrapper classes for the official MySQL C client API.
			The good mix of C and C++ coding techniques makes the code taste very good.
			</para>
			<para>
			P* wraps destructor functions of MySQL, like <code>mysql_stmt_close()</code> into destructors of it's own classes and forgets about them.
			</para>
		</section>
		<section>
			<title>Important functionality to-be-written</title>
			<para>
			Help with development is needed! Please consider joining in or submitting code. <email>atle@goliathdns.no</email>
			</para>
			<para>
			<table>
				<title>List of future functionality</title>
				<tgroup cols="2">
				<colspec colname="c1"/>
				<colspec colname="c2"/>
				<thead>
					<row>
						<entry>Function</entry>
						<entry>Status</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Perl-like in-language regular expressions</entry>
						<entry>Partial implementation available from 1.1-alpha1</entry>
					</row>
					<row>
						<entry>File I/O</entry>
						<entry>Not written (supports STDIN)</entry>
					</row>
					<row>
						<entry>HTTP Cookies</entry>
						<entry>Not written</entry>
					</row>
					<row>
						<entry>Character sets</entry>
						<entry>P* is currently only safe with UTF-8</entry>
					</row>
					<row>
						<entry>Database</entry>
						<entry>P* currently only supports simple MySQL prepared statements, run unbuffered</entry>
					</row>
					<row>
						<entry>Apache module</entry>
						<entry>Not written</entry>
					</row>
				</tbody>
				</tgroup>
			</table>
			</para>
		</section>
	</chapter>
</book>
